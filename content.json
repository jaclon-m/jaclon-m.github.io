{"pages":[],"posts":[{"title":"U2-java内存区域与内存溢出异常","text":"1. 运行时数据区Java虚拟机运行时所管理的内存主要包括以下几个区域： 程序计数器 虚拟机栈 本地方法栈 堆 方法区 程序计数器当前线程所执行的字节码的行号指示器，线程私有的。 虚拟机栈 线程私有，“描述方法执行的内存模型”,栈帧创建和销毁–方法调用到完成。 Java内存分为 堆-栈，栈–虚拟机栈-局部变量表：基本数据类型，对象的引用，returnAddress。 long,double类型数据占用两个局部变量空间(Slot)，其余占用一个Slot，局部变量表在编译时分配内存空间–方法需要在帧中分配的局部变量空间是确定的。 线程请求栈深度大于虚拟机所允许的深度：StackOverflowError;虚拟机栈扩展时无法申请到足够内存：OutOfMemoryError 本地方法栈为虚拟机用的的Native方法服务，与虚拟机栈类似(线程私有) 堆线程共享，存放对象实例和数组，垃圾收集主要区域：GC堆，物理上不连续逻辑上连续即可。 方法区 线程共享，存放类信息、常量、静态变量和即时编译器编译 后的代码，逻辑上为堆的一部分，别名：非堆（Non-Heap）. HotSpot虚拟机把方法区称为”永久代”-GC分代收集扩展至方法区–不是一个好方法 方法区的数据不是永久存在，数据回收主要针对常量池的回收和类型卸载。 运行时常量池 方法区的一部分，存放编译期间生产的字面量和符号引用（？），直接引用。 运行期间也可以将新的常量放入池中。例：String的intern()方法。 直接内存NIO中基于通道(Channel)和缓冲区(Buffer)的I/O方式可以使用Native函数库直接分配堆外内存/系统内存。 2. HotSpot虚拟机对象探秘对象的创建 new执行能否在常量池中定义到一个类的符号引用，确认这个类是否被加载，解析和初始化。 为新对象分配内存空间：指针碰撞方法和空闲列表方法–Java堆是否规整–垃圾收集器是否带有压缩整理算法(Compact) 并发情况下的线程安全问题： 对分配内存空间的动作进行同步处理–CAS+失败重试保证更新操作原子性 内存分配动作按照线程划分在不同空间之中进行–TLAB本地线程分配缓冲：-XX:+/-UseTLAB参数 初始化零值–设置对象头–init 对象的内存布局对象头(Header)，实例数据(Instance Data)，填充信息(Padding) header: 存储对象自身的运行时数据-Mark Word（对象在不同状态下Mark Word存储内容不同） 类型指针 数组–记录长度的数据 Instance Data: Padding: HotSpot要求对象起始地址必须为8字节的整数倍 对象的访问定位 使用句柄 直接指针 3. OutOfMemoryError异常小总结 java堆溢出 内存泄漏(Memory Leak):对象没有被引用了，但是没有被垃圾回收，导致堆内存不够用。 内存溢出(Memory Overflow)：内存中对象必须存活，但是对象太多导致堆内存不够用。 通过参数-XX:+HeapDumpOnOutOfMemoryError查看虚拟机在出现内存溢出时Dump出的当前内存的堆转储快照来分析。分析工具：Memory AnalyzerMemory Analyzer使用：https://blog.csdn.net/wizard_rp/article/details/73266194https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html内存泄漏可以分析原因，内存溢出可以考虑调整虚拟机参数加大内存或者检查代码减少运行内存占用。 虚拟机栈和本地方法栈溢出 StackOverflowError异常 public class JavaVMStackOf { private int stacklength = 1; public void stackLeak(){ stacklength++; stackLeak(); } public static void main(String[] args) { JavaVMStackOf javaVMStackOf = new JavaVMStackOf(); try { javaVMStackOf.stackLeak(); } catch (Exception e) { System.out.println(javaVMStackOf.stacklength); } } } OutOfMemoryError异常一般由多线程导致，且不容器找到原因。（代码由于在本机运行时死机消失了，懒得贴出了） 方法区和运行时常量池异常 public class RuntimeConstantPoolOOM { public static void main(String[] args) { /*List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while(true){ list.add(String.valueOf(i++).intern()); }*/ String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;r&quot;).toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString(); System.out.println(str2.intern() == str2); } } 由于jdk1.7将运行时常量池移出了方法区，所有加/**/代码运行时不会出现异常。 未加注释的段落jdk1.6运行结果false false,jdk1.7结果为true false。intern()方法在1.7中不再会复制首次出现的字符串实例，而是在常量池中记录首次出现额实例的引用。 本机直接内存溢出 public class DirectMemoryOOM { private static final int _1MB = 1024*1024; public static void main(String[] args) { Field field = Unsafe.class.getDeclaredFields()[0]; field.setAccessible(true); try { Unsafe unsafe = (Unsafe)field.get(null); while(true){ unsafe.allocateMemory(_1MB); } } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 如果Heap Dump文件没有明显异常，OOM后dump文件很小，程序中直接或间接使用了NIO，可以考虑这方面原因。","link":"/2018/11/18/U2-java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"},{"title":"OpenJDK编译","text":"准备 获取源码：进入官网 https://jdk7.java.net/source.html选择JavaSE7 ，点击下面的zip file会进入源码下载链接 RI Source Code The source code of the RI binaries is available under the GPLv2 in a single zip file (md5) 100 MB. 系统需求：这里我使用的是CentOS7.仔细阅读源码包中README-builds.html文档，就可以构建编译环境了(忘记读了。。。） 配置环境变量编译依赖：OpenJDK包括虚拟机Hotsport | JDK API | JAXWS | JAXP等。需要各种编译依赖，包括C++，C的编译环境，编译Java的JDK(称为Bootstrap JDK)，还有用于执行java代码的Ant脚本等等。这些依赖在Linux中都可以通过命令一次安装完成。 sudo yum install build-essential gawk m4 libasound2-dev libcups-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant 环境变量：可以编辑/etc/profile，但这里我不想在里面加内容，就在openjdk目录下写了个environments_set.sh，使用./environments_set.sh运行 export LANG=C #BootStrap-JDK的安装路径，替换为自己bootstrap-JDK的路径 export ALT_BOOTDIR=/opt/jdk1.7.0_79/ #允许自动下载依赖 export ALLOW_DOWNLOADS=true #并行编译的线程数 export HOTSPOT_BULLD_JOBS=4 export ALT_PARALLEL_COMPILE_JOBS=4 export SKIP_COMPARE_IMAGES=true #使用预编译头文件，不加这个编码会慢一些 export USE_PRECOMPILED_HEADER=true #要编译的内容，读者可以根据需要自行选择 export BUILD_LANGTOOLS=true #export BUILD_JAXWS=false #export BUILD_JAXP=false #export BUILD_CORBA=false export BUILD_HOTSPOT=true export BUILD_JDK=true #false避开javaws和浏览器java插件之类部分的build BUILD_DEPLOY=false #false这样不会产生安装包，因为安装包中有些奇怪的依赖 BUILD_INSTALL=false #编译结果存放的路径，建议存放在openjdk源码中build文件夹 export ALT_OUTPUTDIR=/home/openjdk/build #这两个环境变量需要去掉，不然会出问题 unset JAVA_HOME unset CLASSPATH make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log编译过程编译会出现很多错误，接觉方式主要参考下面博客http://chenjingbo.iteye.com/blog/1117021http://www.mamicode.com/info-detail-1986398.html 只有这个错误解决时间比较长 bin/ld: cannot find -lstdc++ collect2: error: ld returned 1 exit status ln: failed to access ‘libjvm.so.1‘: Too many levels of symbolic links /usr/bin/chcon: failed to get security context of ‘libjvm.so‘: Too many levels of symbolic links ERROR: Cannot chcon libjvm.so /usr/bin/objcopy --only-keep-debug libjvm.so libjvm.debuginfo /usr/bin/objcopy: Warning: could not locate ‘libjvm.so‘. reason: Too many levels of symbolic links make[6]: *** [libjvm.so] Error 1 make[6]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir/linux_amd64_compiler2/product‘ make[5]: *** [the_vm] Error 2 make[5]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir/linux_amd64_compiler2/product‘ make[4]: *** [product] Error 2 make[4]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir‘ make[3]: *** [generic_build2] Error 2 make[3]: Leaving directory `/root/openjdk_compile/openjdk/hotspot/make‘ make[2]: *** [product] Error 2 make[2]: Leaving directory `/root/openjdk_compile/openjdk/hotspot/make‘ make[1]: *** [hotspot-build] Error 2 make[1]: Leaving directory `/root/openjdk_compile/openjdk‘ make: *** [build_product_image] Error 2在安装了libstdc++-static.x86_64依然出现ERROR: Cannot chcon libjvm.so错误删除了build文件夹重新运行解决。 其中还出现了/目录空间不足的问题，把openjdk由/opt放到/home下。删除了/下几个文件解决。加强了对系统挂载的理解。 运行位置/home/openjdk/build/hotspot/outputdir/linux_amd64_compiler2/product运行参考博文：https://www.cnblogs.com/ACFLOOD/p/5528035.htmlhttps://blog.csdn.net/m0_37726449/article/details/81233853","link":"/2018/11/18/OpenJDK%E7%BC%96%E8%AF%91/"},{"title":"U3-垃圾收集器和内存分配策略","text":"本章讨论的垃圾收集和内存回收都是发生在堆和方法区的。 对象已死吗这里主要讲如何判断一个对象的死亡 引用计数算法时给对象添加一个引用计数器，每当有地方引用它，计数器值加一，引用失效时，计数器值减一；当计数器值为0的对象就是不能再被使用的。问题：解决不了对象之间循环引用的问题。 可达性分析算法从一系列称为“GC Roots”的根节点开始往下搜索，当一个对象到“GC Roots”没有任何引用链时，此对象不可用。GC Roots： 虚拟机栈（栈中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（即一般所说的native方法）引用的对象 引用（reference）JDK1.2以前定义：如果一个refenrece类型数据中的数值代表另一块内存的地址，我们就称它为引用类型的数据缺点：太过狭隘，我们希望能够描述这样的一类对象-内存空间足够则保留在内存中，不够则被回收。JDK1.2以后： 强引用（Strong Reference）：普通意义上的引用，例如：Object obj = new Object(); 软引用（Soft Reference）：内存足够时存在，不够时回收 Object obj = new Object(); SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj); obj = null; sf.get();//有时候会返回null 弱引用（Weak Reference）：被弱引用的对象只能存活到下一次垃圾收集之前 Object obj = new Object(); WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj); obj = null; wf.get();//有时候会返回null wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 虚引用（Phantom Reference）：唯一目的：在这个对象被收集器回收时得到一个系统通知。对象的虚引用不对其生存时间构成影响，也无法通过虚引用获得一个对象。 Object obj = new Object(); PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj); obj=null; pf.get();//永远返回null pf.isEnQueued();//返回是否从内存中已经删除 finalize()方法对象死亡的过程：可达性分析发现没有GC Roots引用链——第一次标记筛选：是否有必要执行finalize()方法—— 对象没有覆盖finalize()方法或者该方法已被执行——对象死亡 需要执行finalize()方法：进入 F-Queue队列，由Finalizer线程执行——进行第二次标记——如果对象在finalize()方法中拯救了自己（成功与引用链上的对象关联即可），则可以再次存活，否则死亡。注意：一个对象的finalize()方法只会执行一次。最好不要使用这个方法。 回收方法区永久代主要回收废弃常量和无用的类。判断无用的类必须同时满足： 该类所有实例已经被回收 加载该类的类加载器已经被回收 该类对应的java.lang.class对象没有在任何地方被引用，无法通过反射访问该类的方法 垃圾收集算法 标记清除（Mark-Sweep）标记需要回收的对象，标记完成后统一回收。问题：效率低，产生不连续内存碎片 复制算法将内存分为相等的两块，每次使用一块，垃圾回收时将可用对象复制到另一块内存上。确定：内存缩小一半，代价太高现代商业虚拟机做法： 整个堆内存分为新生代和老年带 在新生代将内存分为一个Eden区和两个survivor区-8：1：1 每次使用一个Eden区和一个survivor区，垃圾回收时将存活对象复制到另外一个survivor区 如果survivor不够用，则使用老年代进行分配担保 标记整理（Mark-Compact） 老年代使用的算法与标记清除类似，但是后续步骤不是直接清理，而是将可用对象都向一端移动，然后清理到边界以外的内存4. 分代收集算法将Java分为新生代和老年代，新生代采用复制算法，老年代采用标记清除或者标记整理算法。 HotSpot的算法实现 枚举根节点GC Roots 节点找引用链这个操作：不可能逐个检查所有引用，GC时其它线程必须停止工作，保证分析过程中对象引用的关系不发生变化。虚拟机有办法直接得知那些地方存放着对象的引用：HotSpot使用OoMap的数据结构来达到目的。在类加载的时候就把对象在什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会记录下栈和寄存器哪些位置是引用 安全点（SafePoint）不能为每一条指令都生成Oomap记录，只有在特定位置（安全点）才生成OoMap，程序执行时到达安全点才进行GC。安全点的选定：以“是否具有让程序长时间执行的特征”为标准–指令的复用：方法调用，循环跳转，异常跳转等。。。如果让GC发生时所用线程都跑到最近的安全点上停下： 抢先式中断：所有线程停下，发现不在安全点上的恢复，让其执行到安全点 主动式中断：设置标志，线程轮询，主动挂起。标志的地方与安全点重合 安全区域（Safe Region）解决线程不执行（没有分配CP=时间）时进入GC的问题。安全区域：一段代码中引用关系不会发生变化的区域，在这个区域的任意位置开始GC都是安全的。过程：线程执行到Safe Region时标准自己进入Safe Region了，JVM要执行GC时不对进入Safe Region的线程进行检查。当线程出Safe Region时检查是否已经完成枚举根节点（或者整个GC）操作，如果完成则继续执行，否则等待。 垃圾收集器HotSpot虚拟机的垃圾收集器 Serial收集器最基本的新生代收集器，进行垃圾收集时，必须暂停其它所有的工作线程。（stop the world）虚拟机client模式下默认的新生代收集器 ParNew收集器新生代收集器，Serial的多线程版本。Server模式下虚拟机首选的新生代收集器。原因是除了Serial外，目前（jdk1.7 u40 update）只有它能和CMS收集器配合工作。CMS无法与Parallel Scavenge收集器配合工作。单CPU环境下工作效率不比Serial New好多少，多CPU下表现良好。垃圾收集器上下文语境中并发与并行的概念 ： 并行： 多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态。 并发： 用户线程与垃圾收集线程同时执行（可能会交替执行），用户线程在继续运行，而垃圾收集线程运行在另外一个CPU上。 Parallel Scavenge收集器同ParNew一样采用复制算法的新生代收集器。CMS关注“尽可能缩短垃圾收集时用户线程的停顿时间”，Parallel Scavenge关注“达到一个可控制的吞吐量”，适用于后台运算而不需要太多交互任务。吞吐量：CPU用于运行用户代码的时间与CPU总耗时的比值。XX:+UseAdaptiveSizePolicy–GC自适应调节策略。 Serial Old收集器Serial收集器的老年代版本，client模式下的虚拟机使用。Server模式下-jdk1.5版本与Parallel Scavenge配合使用；作为CMS收集器的后备预案 Parallel Old收集器Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法。解决了Parallel Scavenge+Serial Old吞吐量还不如ParNew+CMS的组合。吞吐量优先的环境下，可以使用Parallel Scavenge+Parallel Old收集器 CMS（Concurrent Mark Sweep）收集器获取最短回收停顿时间，服务端，基于标记清除算法。过程： 初始标记：标记一下GC Roots能直接关联到的对象 并发标记：进行GC Roots Tracing 重新标记：修正并发标记阶段因用户程序运行导致标记产生变动的对象的标记记录 并发清除 如图缺陷： 对CPU资源非常敏感：CPU数量小于4个的时候，影响明显。 无法处理浮动垃圾：并发清除阶段用户线程产生的垃圾叫浮动垃圾。CMS收集器需要预留一部分空间供并发的用户线程使用，无法等到老年代全部填满再进行垃圾收集。JDK1.6中阈值提高到92%。CMS运行期间预留内存无法满足需求–Concurrent Mode Failure–临时启用Serial Old进行老年代收集。 产生大量空间碎片： +UseCMSCompactAtFullCollection进行碎片合并整理。 G1（Garbage First）收集器特点： 并行与并发：仍然有利用多核CPU的特点 分代收集 空间整合：整体来看基于标记-整理算法，局部（两个Region之间）基于复制算法 可预测的停顿：让使用者指定在M毫秒的时间片内，垃圾收集时间不超过Ｎ毫秒 G1收集器之前的垃圾收集范围是整个新生代或老年代。G1收集器java内存布局分为多个大小相等的独立区域（Region）。但仍保留新生代和老年代的概念。建立可预测的停顿时间模型：跟踪各个Region里面垃圾堆积的价值大小，优先回收价值最大的Region。如何避免可达性分析中判定对象是否存活扫描整个java堆：Remembered Set:虚拟机对Reference数据写操作时，检查Reference引用的对象是否处于不同的Region，通过CardTable将相关引用信息记录到被引用对象所属Region的Remembered Set中。进行枚举根节点的时候，加入Remembered Set大致步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 理解GC日志 33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs] 100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] “33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。 “［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的；例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。 [Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] “［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。 后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。 而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。 “0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。 内存分配和回收策略 对象优先在Eden区分配 新生代 GC（Minor GC） 老年代 GC（Major GC/Full GC）对象优先在Eden区分配，空间不足，发生Minor GC 大对象直接进入老年代大量连续内存空间的java对象-很长的字符串，数组。 -XX:PretenureSizeThreshold参数（单位 kb）3. 长期存活对象将进入老年代阈值默认为15，-XX:MaxTenuringThreshold设置4. 动态对象年龄判断Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代5. 空间分配担保Minor GC之前–虚拟机检查老年代最大可用的连续空间是否大于新生代所有对象总空间 - 成立，那么Minor GC可以确保是安全的。 - 不成立，HandlePromotionFailure设置值是否允许担保失败–允许，续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， - 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的； - 如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 **注意：**JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略","link":"/2018/11/18/U3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"},{"title":"bat命令学习","text":"基础部分一、介绍 批处理文件是一个“.bat”结尾的文本文件，这个文件的每一行都是一条DOS命令。可以使用任何文本文件编辑工具创建和修改。 批处理是一种简单的程序，可以用 if 和 goto 来控制流程，也可以使用 for 循环。 批处理的编程能力远不如C语言等编程语言，也十分不规范。 每个编写好的批处理文件都相当于一个DOS的外部命令，把它所在的目录放到DOS搜索路径(path)中，即可在任意位置运行。 C:\\AUTOEXEC.BAT 是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。 大小写不敏感(命令符忽略大小写) 批处理的文件扩展名为 .bat 或 .cmd。 在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用cmd.exe来运行该文件。 二、参数 系统参数 %SystemRoot% === C:\\WINDOWS (%windir% 同样) %ProgramFiles% === C:\\Program Files %USERPROFILE% === C:\\Documents and Settings\\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等) %APPDATA% === C:\\Documents and Settings\\Administrator\\Application Data %TEMP% === C:\\DOCUME~1\\ADMINI~1\\LOCALS~1\\Temp (%TEM% 同样) %APPDATA% === C:\\Documents and Settings\\Administrator\\Application Data %OS% === Windows_NT (系统) %Path% === %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem (原本的设置) %HOMEDRIVE% === C: (系统盘) %HOMEPATH% === \\Documents and Settings\\Administrator :: 枚举当前的环境变量 setlocal enabledelayedexpansion FOR /F &quot;usebackq delims==&quot; %%i IN (`set`) DO @echo %%i !%%i! 传递参数给批处理文件%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。Sample： call test2.bat &quot;hello&quot; &quot;haha&quot; (执行同目录下的“test2.bat”文件，并输入两个参数) 在“test2.bat”文件里写: echo %1 (打印: &quot;hello&quot;) echo %2 (打印: &quot;haha&quot;) echo %0 (打印: test2.bat) echo %19 (打印: &quot;hello&quot;9) 批处理基本命令 help命令(/?)语法： 命令 /?可显示此命令的帮助信息 type /? &gt;&gt;tmp.txt (把 type 命令的帮助信息写入到tmp.txt文件里) help type (显示跟“type /?”一样) echo命令语法: echo [on|off] [message]ECHO [ON | OFF] 打开回显或关闭回显功能。ECHO 显示当前回显设置。ECHO [message]显示信息。echo off 表示在此语句后所有运行的命令都不显示命令行本身；默认是on，on时会显示如： C:\\文件夹路径&gt;命令行。在实际应用中我们会把这条命令和重定向符号( 也称为管道符号，一般用 &gt; &gt;&gt; ^ )结合来实现输入一些命令到特定格式的文件中。sample1: F:\\&gt;echo hello world hello world F:\\&gt;echo on F:\\&gt;echo helloworld helloworld F:\\&gt;echo off echo helloworld helloworldsample2: echo Windows Registry Editor Version 5.00 &gt; c:\\setupreg.reg (此前还没有 setupreg.reg 这个文件) echo &quot;SourcePath&quot;=&quot;D:\\\\Win2003\\\\&quot; &gt;&gt; c:\\setupreg.reg (追加内容进 setupreg.reg 这个文件) @命令表示不显示@后面的命令，(在入侵过程中自然不能让对方看到你使用的命令啦)@ 与 echo off 相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行(只能影响当前行)。 @echo off (此语句常用于开头，表示不显示所有的命令行信息，包括此句) @echo please wait a minite... Rem命令语法：Rem Message…(小技巧：用::代替rem)注释命令，在C语言中相当与/…/,它并不会被执行，只是起一个注释的作用，便于别人阅读和自己日后修改。 goto命令语法：goto label (label是参数，指定所要转向的批处理程序中的行。)指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。label标签的名字可以随便起，但是最好是有意义的，字母前必须加个冒号“:”来表示这个字母是标签。goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if 配合使用，根据不同的条件来执行不同的命令组。 Pause 命令会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续sample: @echo off :begin copy a:*.* d:\\back echo Please put a new disk into driver A pause goto begin在这个例子中，驱动器 A 中磁盘上的所有文件均复制到d:\\back中。显示的信息提示您将另一张磁盘放入驱动器 A 时，pause 命令会使程序挂起，以便您更换磁盘，然后按任意键再次复制。 call 命令语法: call [[Drive:][Path] FileName [BatchParameters]] [:label [arguments]]参数: [Drive:][Path] FileName 指定要调用的批处理程序的位置和名称。filename 参数必须具有 .bat 或 .cmd 扩展名。调用另一个批处理程序，并且不终止父批处理程序。如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用 call，它将不会在命令行起作用。 call=&quot;%cd%\\test2.bat&quot; haha kkk aaa (调用指定目录下的 test2.bat，且输入3个参数给他) call test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他)注：可以调用自身(死循环、递归) start 命令调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令 来调用。常用参数： MIN 开始时窗口最小化 SEPARATE 在分开的空间内开始 16 位 Windows 程序 HIGH 在 HIGH 优先级类别开始应用程序 REALTIME 在 REALTIME 优先级类别开始应用程序 WAIT 启动应用程序并等候它结束 parameters 这些为传送到命令/程序的参数 start /MIN test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他，且本窗口最小化) e:\\&quot;program files&quot;\\极品列车时刻表\\jpskb.exe (文件路径名有空格时) if else IF语法: if [not] “参数” == “字符串” 待执行的命令参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号) if &quot;%1&quot; == &quot;a&quot; format a: if {%1} == {} goto noparms if exist语法: if [not] exist [路径]文件名 待执行的命令如果有指定的文件，则条件成立，运行命令，否则运行下一句。 if exist config.sys edit config.sys (表示如果存在这文件，则编辑它) if exist config.sys type config.sys (表示如果存在这文件，则显示它的内容) if errorlevel number语法: if [not] errorlevel &lt;数字&gt; 待执行的命令如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列) @echo off XCOPY F:\\test.bat D:\\ IF ERRORLEVEL 1 (ECHO 文件拷贝失败 ) Else IF ERRORLEVEL 0 ECHO 成功拷贝文件 pause很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。常见的返回码为0、1。通过if errorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。 else语法： if 条件 (成立时执行的命令) else (不成立时执行的命令)如果是多个条件，建议适当使用括号把各条件包起来，以免出错。 if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) else (echo comment3 )注：如果 else 的语句需要换行，if 执行的行尾需用“^”连接，并且 if 执行的动作需用(括起来)，否则报错 if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) ^ else (echo comment3 ) 比较运算符:EQU - 等于 (一般使用“==”)NEQ - 不等于 (没有 “!=”,改用“ if not 1==1 ”的写法)LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于 choice 命令choice 使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的 errorlevel，然后配合 if errorlevel 选择运行不同的命令。注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234…… choice /c:dme /m defrag,mem,end if errorlevel 3 goto defrag (应先判断数值最高的错误码) if errorlevel 2 goto mem if errotlevel 1 goto end for命令1) for {%variable | %%variable} in (set) do command [command-parameters]%variable 指定一个单一字母可替换的参数。变量名称是区分大小写的，所以 %i 不同于 %I在批处理文件中使用 FOR 命令时，指定变量建议用 %%variable而不要用 %variable。 注意：在批处理文件中使用%%,命令行显示为%,命令行中要使用一个%,使用%%会报错 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 rem 如下命令行会显示当前目录下所有以bat或者txt为扩展名的文件名。 for %%c in (*.bat *.txt) do (echo %%c) 2) 如果命令扩展名被启用，下列额外的 FOR 命令格式会受到支持: FOR /D %variable IN (set) DO command [command-parameters] 如果set集里面包含通配符，则指定与目录名匹配，而不与文件名匹配。 rem 如下命令行会显示当前目录下所有包含有 e 或者 i 的目录名。 for /D %%a in (*e* *i*) do echo %%a FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。 如果在 /R 后没有指定目录，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。 rem 如下命令行会显示 E盘test目录 下所有以bat或者txt为扩展名的文件名。 for /R E:\\test %%b in (*.txt *.bat) do echo %%b for /r %%c in (*) do (echo %%c) :: 遍历当前目录下所有文件 FOR /L %variable IN (start,step,end) DO command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。 如：(1,1,5) 将产生序列 1 2 3 4 5； 而(5,-1,1) 将产生序列 (5 4 3 2 1)。 rem 如下命令行将产生序列 1 2 3 4 5 for /L %%c in (1,1,5) do echo %%c 有或者没有 usebackq 选项: FOR /F [&quot;options&quot;] %variable IN (file-set) DO command FOR /F [&quot;options&quot;] %variable IN (&quot;string&quot;) DO command FOR /F [&quot;options&quot;] %variable IN (command) DO command 参数”options”为: eol=c - 指一个行注释字符的结尾(就一个,如“;”) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。m-n格式为一个范围。如果符号字符串中的最后一个字符为星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 filenameset中使用双引号扩起文件名称。 以下两句，显示当前的年月日和时间 For /f &quot;tokens=1-3 delims=-/. &quot; %%j In (&apos;Date /T&apos;) do echo %%j年%%k月%%l日 For /f &quot;tokens=1,2 delims=: &quot; %%j In (&apos;TIME /T&apos;) do echo %%j时%%k分 把记事本中的内容每一行前面去掉8个字符 setlocal enabledelayedexpansion for /f %%i in (zhidian.txt) do ( set atmp=%%i set atmp=!atmp:~8! if {!atmp!}=={} ( echo.) else echo !atmp! ) :: 读取记事本里的内容(使用delims 是为了把一行显示全,否则会以空格为分隔符) for /f &quot;delims=&quot; %%a in (zhidian.txt) do echo.%%a 注： setlocal enabledelayedexpansion开启扩展参数延迟，将在后面讲解。 ~8意思为从字符串的第8个字符开始截取，有关字符串截取在后面讲解。 经过试验，注释部分会读取错误，截取纯文本没有问题，但是当截取含有特殊符号的文本时（比如本文中上面一段）并没有得到想要的结果，不知为何。 3) continue 和 break 利用 goto 实现程序中常用的 continue 和 break 命令, 其实非常简单 continue: 在 for 循环的最后一行写上一个标签，跳转到这位置即可 break: 在 for 循环的外面的下一句写上一个标签，跳转到这位置即可 for /F [&quot;options&quot;] %variable IN (command) DO ( ... do command ... if ... goto continue if ... goto break ... do command ... :continue ) :break 三、其它命令 ping 命令测试网络联接状况以及信息包发送和接收状况。但是不能够测试端口。 语法：ping IP地址或主机名 [-t] [-a] [-n count] [-l size]参数含义： -t 不停地向目标主机发送数据；-a 以IP地址格式来显示目标主机的网络地址；-n count 指定要Ping多少次，具体次数由count来指定；-l size 指定发送到目标主机的数据包的大小。 ping 192.168.0.1 -t (不停的测试192.168.0.1，按ctrl+c停止) for /L %%a in (0,1,255) do ping 192.168.0.%%a -n 1 &gt;&gt; tmp.txt (ping一下所有的局域网电脑) telnet 命令测试端口使用 telnet IP地址或主机名 端口，使用tcp协议的 telnet 192.168.0.1 80 (测试192.168.0.1的80端口) color 命令设置背景及字体颜色 语法： color bfb 是指定背景色的十六进制数字； f 指定前景颜色(即字体颜色)。颜色值: 0:黑色 1:蓝色 2:绿色 3:湖蓝 4:红色 5:紫色 6:黄色 7:白色 8:灰色 9:淡蓝 A:淡绿 B:浅绿 C:淡红 D:淡紫 E:淡黄 F:亮白如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时的颜色。如果两参数一样，视为无效输入。只有一个参数时，设置字体。 random 命令产生随机数(正整数0~)，要使用random，必须将其当作一个变量来使用，这样才能得到值。 echo %random%%random%可以产生0到65535之间的随机数。通过获得一定范围内的随机数：通用的算法公式如： %random%%%(max-min+1)+min来产生[min,max]区间里的随机数注：批处理中求模得用两个%%符号。 @REM 产生10个[4,12]间的随机数 @echo off REM 启用延迟环境变量扩展 setlocal enabledelayedexpansion REM 设置随机数的最小和最大值以及求模用的变量 set min=4 set max=12 set /a mod=!max!-!min!+1 for /l %%i in (1,1,10) do ( REM 产生[min,max]之间的随机数 set /a r=!random!%%!mod!+!min! echo. echo 随机数%%i：!r! )参考链接 exit 命令结束程序。即时是被调用的程序，结束后也不会返回原程序 shutdown命令shutdown -s 关机 所有内置命令的帮助信息ver /?cmd /?set /?rem /?if /?echo /?goto /?for /?shift /?call /?其他需要的常用命令type /?find /?findstr /?copy /? 四、字符串处理 分割字符串，以查看时间为例%源字符串:~起始值,截取长度% (起始值从0开始；截取长度是可选的，如果省略逗号和截取长度，将会从起始值截取到结尾；截取长度如果是负数，表示截取到倒数第几个。) &quot;%time%&quot; 显示如：&quot;11:04:23.03&quot; (完整的时间&quot;hh:mm:ss.tt&quot;) &quot;%time:~0,5%&quot; 显示&quot;hh:mm&quot;(即&quot;11:04&quot;)，其中0表示从右向左移位操作的个数，5表示从左向右移位操作的个数 &quot;%time:~0,8%&quot; 显示标准时间格式&quot;hh:mm:ss&quot;(即&quot;11:04:23&quot;，前8个字符串) &quot;%time:~3,-3%&quot;显示&quot;mm:ss&quot;(即从第4个开始,截去最后3个的字符串) &quot;%time:~3%&quot; 显示&quot;04:23.03&quot;(即去掉前4个字符串) &quot;%time:~-3%&quot; 显示&quot;.tt&quot;(即最后3个字符串)上面的字串分割格式，也可以用于其它地方，如目录路径：”%cd:~0,10%” 替换字符串 set a=&quot;abcd1234&quot; echo %a% 显示：&quot;abcd1234&quot; set a=%a:1=kk% 替换“1”为“kk” echo %a% 显示：&quot;abcdkk234&quot; 字符串合并 set str1=%str1%%str2% (合并 str1 和 str2) 计算字符串长度没有现成的函数。如下程序利用 goto形成循环，不断将字符串截短1，并记录截短的次数，到字符串变成空时的次数即长度。 set testStr=This is a test string :: 将 testStr 复制到str，str 是个临时字符串 set str=%testStr% :: 标签，用于goto跳转 :next1 :: 判断str是不是空，如果不是则执行下边的语句 if not &quot;%str%&quot;==&quot;&quot; ( :: 算术运算，使num的值自增1，相当于num++或者++num语句 set /a num+=1 :: 截取字符串，每次截短1 set &quot;str=%str:~1%&quot; :: 跳转到next1标签: 这里利用goto和标签，构成循环结构 goto next1 ) :: 当以上循环结构执行完毕时，会执行下边的语句 echo testStr=%testStr% echo testStr的长度为：%num% 截取字符串时，需要传递参数直接 echo %args:~%num%,-5% 没办法想要的字符串，需要如下两步 setlocal enabledelayedexpansion echo !args:~%num%,-5! 五、系统服务 停止服务：NET STOP 服务名启动服务：NET Start 服务名 设置启动类型自动： SC CONFIG 服务名 START= auto手动： SC CONFIG 服务名 START= demand已禁用：SC CONFIG 服务名 START= disabled附：“START= ”等号后面必须要有一个空格。(start还有boot,system两个值)Sample: SC CONFIG Spooler START= demand (打印机加载项，设置成手动，默认自动) 查看系统服务：start %SystemRoot%\\system32\\services.msc /s 六、setlocal与变量延迟 批处理中setlocal enabledelayedexpansion的含义参考链接注意两点： 什么叫环境变量扩展和延迟环境变量扩展 延迟的变量用！！表示 启动批处理文件中环境变量的本地化。本地化将持续到出现匹配的 endlocal 命令或者到达批处理文件结尾为止。语法: setlocal {enableextension | disableextensions} {enabledelayedexpansion | disabledelayedexpansion}enableextension: 启用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。disableextensions: 禁用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。enabledelayedexpansion: 启用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。disabledelayedexpansion: 禁用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 七、文件处理 删除 删除一个文件或多个文件del /s /q /f d:\\test\\a.bat将直接删除d:\\test\\a.bat，没有任务提示del temp* /q /f /s将直接删除 本目录的 temp 目录的所有文件，没有任务提示删除文件的时候可以使用“*”作通配符 删除一个空目录rd /q /s d:\\test\\log将直接删除d:\\test\\log目录，如果log目录里面有文件将无法删除 删除一个非空目录 (必须指定目录名称)rmdir /q /s d:\\test\\logs必须指定目录名称，不能使用通配符/S 除目录本身外，还将删除指定目录下的所有子目录/Q 安静模式，带 /S 删除目录树时不要求确认无论里面是否有文件或文件夹将全部直接删除 创建目录MKDIR [drive:]pathMD [drive:]path路径有空格时，可以用双引号括起来，也可以用 &nbsp; 替代 实践部分1.小摘录 调用其他程序时，对文件的大小写不敏感，文件后缀也可忽略如：start LeapFTP.exe 与 start leapftp 效果一样，都是运行“LeapFTP.exe”文件 每行的开头的字符串会自动查找程序来运行，还可用双引号引起来(文件名或目录名含空格时必须用)如：”D:\\Program Files\\Leap FTP.exe”“LeapFTP.exe” 可正常运行文件（在原窗口）start “标题” “LeapFTP.exe” start是在新窗口运行(第一个参数是窗口显示的标题) copy C:\\test*.* D:\\back (复制C盘test文件夹的所有文件(不包括文件夹及子文件夹里的东西)到D盘的back文件夹) dir c:*.* &gt; a.txt (将c盘文件列表写入 a.txt 中) &gt; 生成文件并写入内容(如果有这文件则覆盖)， &gt;&gt; 文件里追加内容 md d:\\aa (创建文件夹) 在命令末尾加上“&gt;NUL 2&gt;NUL”，表示隐蔽返回信息。 等待用户输入： set /p 变量名=屏幕显示信息。set是对参数的定义，动态的话需要加上/p的条件，“=”后面的内容便是对这个参数的描述，在用户需要输入值得时候提示用户。 set /p a=请输入a: set /p b=请输入b: echo %a% %b% pause&gt;nul 让用户按回车退出小技巧(替代pause)，文件的最后一句：set /p tmp=操作结束，请按回车键退出… 设置标题： title JDK安装 清屏： cls 修改文件的更新日期copy 文件名+‘’&gt;nul (修改为当前时间，如果要修改为指定时间，先修改系统时间，再改回系统时间) 修改文件的后缀名ren C:\\test*.jpg .JPGfor /r %%c in (.jpg) do (ren %%c *.JPG) :: 修改当前目录下的所有文件的后缀名，包括子目录的 修改文件的文件名rename test.jpg test2.JPGrename *.jpg *.888.JPG 共享A.查看你机器的共享资源: net shareB.手工删除共享 net share 共享资源名称$ /d 注意$后有空格。C.增加一个共享： net share mymovie=e:\\downloads\\movie /users:3 mymovie 共享成功。 同时限制链接用户数为3人。 实例收集 在批处理中使用密码。密码为admin，输入正确，跳转到next1 ，若输入密码错误3次，则锁屏。。 @echo off set num=0 :11 set /p pass=请输入密码: if &quot;%pass%&quot;==&quot;admin&quot; goto next1 set /a num=%num% + 1 if %num%==3 goto no1 goto 11 :no1 %windir%\\system32\\rundll32.exe user32.dll,LockWorkStation goto 11 :next1 echo 密码正确，执行下面的程式 pause 坑 部分命令直接在cmd窗口中运行不了，要写入.bat文件中运行 网上查询的或者实例中的命令运行不了，提示”XXX不是有效命令”。–原因是我把系统默认的记事本编辑器改为notepad了，用notpad编辑的bat文件，每行的头部少一些东西吧。当我重新建一个bat文件，用sublimetext打开编辑的时候，就好了（不要问我为何不用系统记事本233333~）。另外注意编码格式要选择GBK或者ANSI，否则会有中文乱码问题。 参考链接：Bat命令学习","link":"/2018/10/13/bat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/15/hello-world/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"bat命令","slug":"bat命令","link":"/tags/bat%E5%91%BD%E4%BB%A4/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"生产工具","slug":"生产工具","link":"/categories/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"},{"name":"JVM","slug":"编程语言/JVM","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JVM/"}]}