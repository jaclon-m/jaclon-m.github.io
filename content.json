{"pages":[],"posts":[{"title":"OpenJDK编译","text":"准备 获取源码：进入官网 https://jdk7.java.net/source.html选择JavaSE7 ，点击下面的zip file会进入源码下载链接 RI Source Code The source code of the RI binaries is available under the GPLv2 in a single zip file (md5) 100 MB. 系统需求：这里我使用的是CentOS7.仔细阅读源码包中README-builds.html文档，就可以构建编译环境了(忘记读了。。。） 配置环境变量编译依赖：OpenJDK包括虚拟机Hotsport | JDK API | JAXWS | JAXP等。需要各种编译依赖，包括C++，C的编译环境，编译Java的JDK(称为Bootstrap JDK)，还有用于执行java代码的Ant脚本等等。这些依赖在Linux中都可以通过命令一次安装完成。 sudo yum install build-essential gawk m4 libasound2-dev libcups-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant 环境变量：可以编辑/etc/profile，但这里我不想在里面加内容，就在openjdk目录下写了个environments_set.sh，使用./environments_set.sh运行 export LANG=C #BootStrap-JDK的安装路径，替换为自己bootstrap-JDK的路径 export ALT_BOOTDIR=/opt/jdk1.7.0_79/ #允许自动下载依赖 export ALLOW_DOWNLOADS=true #并行编译的线程数 export HOTSPOT_BULLD_JOBS=4 export ALT_PARALLEL_COMPILE_JOBS=4 export SKIP_COMPARE_IMAGES=true #使用预编译头文件，不加这个编码会慢一些 export USE_PRECOMPILED_HEADER=true #要编译的内容，读者可以根据需要自行选择 export BUILD_LANGTOOLS=true #export BUILD_JAXWS=false #export BUILD_JAXP=false #export BUILD_CORBA=false export BUILD_HOTSPOT=true export BUILD_JDK=true #false避开javaws和浏览器java插件之类部分的build BUILD_DEPLOY=false #false这样不会产生安装包，因为安装包中有些奇怪的依赖 BUILD_INSTALL=false #编译结果存放的路径，建议存放在openjdk源码中build文件夹 export ALT_OUTPUTDIR=/home/openjdk/build #这两个环境变量需要去掉，不然会出问题 unset JAVA_HOME unset CLASSPATH make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log编译过程编译会出现很多错误，接觉方式主要参考下面博客http://chenjingbo.iteye.com/blog/1117021http://www.mamicode.com/info-detail-1986398.html 只有这个错误解决时间比较长 bin/ld: cannot find -lstdc++ collect2: error: ld returned 1 exit status ln: failed to access ‘libjvm.so.1‘: Too many levels of symbolic links /usr/bin/chcon: failed to get security context of ‘libjvm.so‘: Too many levels of symbolic links ERROR: Cannot chcon libjvm.so /usr/bin/objcopy --only-keep-debug libjvm.so libjvm.debuginfo /usr/bin/objcopy: Warning: could not locate ‘libjvm.so‘. reason: Too many levels of symbolic links make[6]: *** [libjvm.so] Error 1 make[6]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir/linux_amd64_compiler2/product‘ make[5]: *** [the_vm] Error 2 make[5]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir/linux_amd64_compiler2/product‘ make[4]: *** [product] Error 2 make[4]: Leaving directory `/root/openjdk_compile/build/hotspot/outputdir‘ make[3]: *** [generic_build2] Error 2 make[3]: Leaving directory `/root/openjdk_compile/openjdk/hotspot/make‘ make[2]: *** [product] Error 2 make[2]: Leaving directory `/root/openjdk_compile/openjdk/hotspot/make‘ make[1]: *** [hotspot-build] Error 2 make[1]: Leaving directory `/root/openjdk_compile/openjdk‘ make: *** [build_product_image] Error 2在安装了libstdc++-static.x86_64依然出现ERROR: Cannot chcon libjvm.so错误删除了build文件夹重新运行解决。 其中还出现了/目录空间不足的问题，把openjdk由/opt放到/home下。删除了/下几个文件解决。加强了对系统挂载的理解。 运行位置/home/openjdk/build/hotspot/outputdir/linux_amd64_compiler2/product运行参考博文：https://www.cnblogs.com/ACFLOOD/p/5528035.htmlhttps://blog.csdn.net/m0_37726449/article/details/81233853","link":"/2018/11/18/OpenJDK%E7%BC%96%E8%AF%91/"},{"title":"02.RPC核心流程","text":"RPC 的作用就是体现在这样两个方面： 屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑 一个完整的 RPC 会涉及到哪些步骤呢? RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。 网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。 我们把数据格式的约定内容叫做“协议”。大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。根据协议格式， 服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作“反序列化”。 服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用 我们有什么办法来简化 API，屏蔽掉 RPC 细节，让使用方只需要关注业务接口，像调用本地一样来调用远程呢？ 由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。 总结：动态代理 =》 序列化 =》 协议 =》 网络传输（编解码） =》 反序列化 =》 反射执行 扩展你觉得一个设计RPC框架中最重要的是哪一点？”我当时首先说了RPC框架首先是通信、自定义协议（protobuf）、序列化、注册中心。我们的RPC由于C++开发的，只提供消息传输的功能，序列化和协议在应用层做的（主要是考虑不同项目的业务也有区别）。我觉得其中最重要的就是注册中心（数据中心）实现了，这个决定了RPC所能提供扩展功能。 (待补充)","link":"/2020/07/17/02-RPC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"},{"title":"01.基础-网络模型协议","text":"聊一聊TCPIP四层网络模型嘛？OSI七层网络模型也要说一下物理层网线，海底电缆等都属于网络的物理层，在物质层面将两台电脑连接起来，然后传递0/1的电路信号。 数据链路层一套协议，能够实现将物理层的01信号进行分组等处理，规定电信号的含义是什么。很多年前，每个公司都又自己定义的电路信号分组方式，但是后来出来了以太网协议，一组电信号是一个数据包，叫一个帧，每个帧分成两个部分，标头和数据，标头包含一些说明性的东西，比如说发送者、接受者和数据类型之类的。 以太网规定了，每个网卡必须得包含一个mac地址，mac地址就是这个网卡的唯一标识。以太网协议规定了，接入网络里的所有设备，都要有网卡，以太网协议离得那个数据包，在数据链路层传输的数据包，必须从一个电脑的网卡传输到另外一个电脑的网卡，而这个网卡的地址就叫作所谓的mac地址。每块网卡出厂的时候，就有一个唯一的mac地址，48位的二进制，但是一般用12个16进制数字表示，前6个是厂商编号，后6个是网卡流水号。 但是以太网的数据包怎么从一个mac地址发送到另一个mac地址呢？这个不是精准推送的，在以太网中，如果一个电脑发送了一个数据包出去，会广播给局域网内的所有电脑设备的网卡，然后每天电脑都从数据包里获取接收者的mac地址，跟自己的mac地址对比一下，如果一样就说明是自己的数据包。 但是上面这种广播的方式，仅仅是针对一个子网内的电脑，会广播，否则一个电脑不能广播数据包给全世界所有的电脑吧，是仅仅广播给一个子网里面的电脑。 网络层上面说到，子网内的电脑，通过以太网发数据包，对局域网内的电脑，是广播出去的。MAME如何知道哪些电脑在一个子网内呢？这就要靠网络层了，这里就有一套Ip地址，IP地址就可以让我们区分哪些电脑是一个子网的。 网络层里面有个IP协议，ip协议定义的地址就叫作ip地址.有ipv4和v6两个版本，目前使用你较多的是IPV4,是32个二级制数字组成，但是一般用4个十进制数字表示，范围是0.0.0.0到255.255.255.255之间。 每台计算机都会分配一个ip地址，ip地址前24位（就是前面三个十进制数字），代表了网络，后8位代表了主机。如果几台电脑是一个子网的。那么前三个十进制数字一定是一样的。 但是实际上上面就是举个例子，其实单从ip地址是看不出来那些机器是一个子网的，因为从10进制是判断不出来的。需要通过ip地址的二进制来判断，结合一个概念叫作子网掩码。比如说ip地址是192.168.56.1，子网掩码是255.255.255.0。知道了子网掩码之后，如果要判断两个ip地址是不是一个子网的，就分别把两个ip地址和自己的子网掩码进行二进制与运算，比较一下代表网络的那部分。 子网掩码的二进制是：111111111.111111111.111111111.00000000，然后跟ip地址的二进制做与运算，通过二进制来比较网络部分的地址是不是一模一样的。 有了网络层的ip地址之后，两台在子网内的电脑终于可以通过广播+mac地址判断来传输数据包进行通信了。但是如果发现要接收数据包的计算机不在子网内，那么就不能用过广播来发送数据包，需要通过路由来发送数据包。就是我们下面要说的路由。 举个例子，两个局域网之间如果通过一个路由器进行通信的话，是怎么进行的。 大概过程就是，路由器配置了两块网卡，每个网卡可以连接到一个局域网内。局域网1内的电脑要发送数据到局域网2里面的电脑，在数据包里写上自己的ip地址和对方的ip地址。但是他们不再一个局域网内，于是局域网1内的电脑，通过交换机将数据包发送给路由器（网关），这个过程需要将路由器的一块网卡的ip地址对应的mac地址写到数据包的头部，然后才能通过交换机广播出去，路由器收到之后比较自己一块网卡的mac地址，就知道是来找自己的。 接着路由器接收到数据包之后，就会在局域网2内，将目标机器的ip地址对应的mac地址写入头部，接着再次通过交换机发送广播通知，发送给局域网2内的电脑。 如何知道ip地址和mac的对应关系？一个局域网内的每台机器都有自己的ARP cache,用来在一个局域网内让各个设备都知道每个设备的ip地址和mac地址的对应关系。一遍就是某个机器发送广播通知自己的ip地址和mac地址的对应关系，然后每个机器给他一个回应，以此类推。 下面介绍几个概念： 网关网关其实就是路由器的一种，运作在网络层。可以把路由器上的ip地址认为就是网关，路由器上每个网卡都有mac地址和对应的ip地址。路由器虽然有mac地址，但是不能通过mac地址寻址的，必须通过ip地址寻址，所以路由器其实是工作在网络层的设备。（电脑上有默认网关） 网络交换机 也是一种设备，工作在数据链路层，路由器是工作在网络层。网络交换机是通过mac地址来寻址和传输数据包的；但是路由器是通过ip地址寻址和传输数据包的。网络交换机主要用于局域网的通信，一般你架设一个局域网，里面的电脑通信是通过数据链路层发送数据包，通过mac地址来广播的，广播的时候就是通过网络交换机这个设备来实现的；路由器一般用来连入因特网。 LAN WAN WLAN局域网，广域网，无线局域网 假设你访问百度网站，先通过mac地址和交换机广播到默认网关，然后进行一层一层网关在寻址，一直到找到百度所在的那个服务器的ip地址和对应的mac地址（这里也用到交换机在子网的广播），然后传输数据。 传输层这里还有一个问题，就是一台机器上，有很多程序使用一个网卡进行通信，比如浏览器、QQ等。所以还需要一个端口的概念。端口号是0~65536的范围内， 0到1023被系统占用了，定义其它的就可以。 网络层基于ip协议，进行主机之间的寻址和通信，传输层是建立在某个主机的某个端口，到另外一个主机的某个端口的连接和通信的。这个通信就是通过socket来实现的，通过socket就可以基于tcp/ip协议完成上面所说的一系列比如基于ip地址和mac地址转换和寻址，通过路由通信，而且会建立一个端口到另外一个端口的连接。 udp和 tcp,都是传输层的协议，但是一个是可靠的一个是不可靠的。传输层的tcp协议，仅仅只是规定了一套基于端口的点对点通信的协议，包括如何建立连接，如何发送消息和读取消息，但是实际上如果你要基于tcp协议来开发，应该使用socket，它里面就是实现了tcp协议。（实际上底层还是上面介绍的各种东西） 应用层比较常见的，应用层的协议就是http协议，进行网络通信。 4层：数据链路层（以太网协议） ，网络层（ip协议），传输层（tcp协议 ），应用层（http协议）7层：物理层，会话层，表示层和会话层合并成应用层。 扩展问题浏览器请求www.baidu.com的全过程大概是怎么样的？首先我们假设个电脑设置了几个东西：ip地址：192.168.31.37子网掩码：255.255.255.0网关地址：192.168.31.1DNS地址：8.8.8.8百度的ip地址：172.194.16.08 TCP三次握手和四次挥手的流程图？为啥不是两次或者五次呢TODO","link":"/2020/07/17/01-%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8D%8F%E8%AE%AE/"},{"title":"03.dubbo分层设计+核心调用流程","text":"详细设计在dubbo官方文档中已经写得很好了，本文主要是对dubbo文档进行一下总结。 分层和分模块十层结构： business: service RPC: Config Proxy Registry Cluster Monitor Protocol Remoting: exchange Transport Serialize 关系说明： Protocol核心层，Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用 Proxy 接口透明化代理，Invoker和Proxy转化。 Remoting基于Dubbo协议，RMI协议不需要 模块分包： common：含有Serialize Remoting： Dubbo协议实现 RPC： 核心，proxy+protocol 其它：Cluster，Monitor，Config，registry,container 调用过程 总说（参考官网截图）：初始化+调用+监控 远程调用细节 服务提供者暴露一个服务的详细过程首先 ServiceConfig 类拿到对外提供服务的实际类 ref(如：HelloWorldImpl),然后通过 ProxyFactory 类的 getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。接下来就是 Invoker 转换到 Exporter 的过程。Dubbo 处理服务暴露的关键就在 Invoker 转换到 Exporter 的过程。 服务消费者消费一个服务的详细过程首先 ReferenceConfig 类的 init 方法调用 Protocol 的 refer 方法生成 Invoker 实例(如上图中的红色部分)，这是服务消费的关键。接下来把 Invoker 转换为客户端需要的接口(如：HelloWorld)。 满眼都是 Invoker服务消费者代码： 123456789101112public class DemoClientAction { private DemoService demoService; public void setDemoService(DemoService demoService) { this.demoService = demoService; } public void start() { String hello = demoService.sayHello(&quot;world&quot;); }} 上面代码中的 DemoService 就是上图中服务消费端的 proxy，用户代码通过这个 proxy 调用其对应的 Invoker，而该 Invoker 实现了真正的远程服务调用。 服务提供者代码： 123456public class DemoServiceImpl implements DemoService { public String sayHello(String name) throws RemoteException { return &quot;Hello &quot; + name; }} 上面这个类会被封装成为一个 AbstractProxyInvoker 实例，并新生成一个 Exporter 实例。这样当网络通讯层收到一个请求后，会找到对应的 Exporter 实例，并调用它所对应的 AbstractProxyInvoker 实例，从而真正调用了服务提供者的代码。Dubbo 里还有一些其他的 Invoker 类，但上面两种是最重要的。 总结一下： 消费者 生成-&gt; proxy,调用 invoker； 提供者 封装成-&gt;AbstractProxyInvoker-&gt;生成Exporter 提供者收到请求后，找到Exporter，调用对应的AbstractProxyInvoker。 实现细节： http://dubbo.apache.org/zh-cn/docs/dev/implementation.html具体代码 http://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html 一些设计原则摘录： 防止空指针和下标越界，保证线程安全性和可见性 API 与 SPI 分离 检查重复的jar包 ps: dubbo 框架设计的文档写的非常好，在设计思想和规范上都值得借鉴，想要成为一个合格的企业软件开发者，适合多读几遍。","link":"/2020/07/17/03-dubbo%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1-%E6%A0%B8%E5%BF%83%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"},{"title":"HashMap和CurrentHashMap","text":"hashmap 1.7与1.8 的区别面试的时候被问到这个问题了，回答的时候只有数组+链表和数组+链表+红黑树的区别，结果网上一查吓了一跳。。。这里就简单列一下吧。 最重要的一点是底层结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构; jdk1.7中当哈希表为空时，会先调用inflateTable()初始化一个数组；而1.8则是直接调用resize()扩容; 插入键值对的put方法的区别，1.8中会将节点插入到链表尾部，而1.7中是采用头插； jdk1.7中的hash函数对哈希值的计算直接使用key的hashCode值，而1.8中则是采用（key的hashCode） 异或上 （key的hashCode进行无符号右移16位） 的结果，避免了只靠低位数据来计算哈希时导致的冲突，计算结果由高低位结合决定，使元素分布更均匀； 扩容时1.8会保持原链表的顺序，而1.7会颠倒链表的顺序； jdk1.8是扩容时通过hash&amp;cap==0将链表分散，无需改变hash值，而1.7是通过更新hashSeed来修改hash值达到分散的目的； 扩容策略：1.7中是只要不小于阈值就直接扩容2倍；而1.8的扩容策略会更优化，当数组容量未达到64时，以2倍进行扩容，超过64之后若桶中元素个数不小于7就将链表转换为红黑树，但如果红黑树中的元素个数小于6就会还原为链表，当红黑树中元素不小于32的时候才会再次扩容。 这里最重要的是1 4 条，5 6 7 三条次之，说明了hashmap确实经过了很大优化。参考链接：jdk1.7与jdk1.8中HashMap区别 hashmap-currentHashMap 小总结先上链接：HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！ 问题一：HashMap线程不安全问题在1.7的时候可能会像博客中那也说的形成环，报错： 123456at java.lang.Thread.run(Thread.java:745)Exception in thread &quot;Thread-9&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at com.atguigu.juc.test.HelloThread.run(TestCopyOnWrite.java:31) at java.lang.Thread.run(Thread.java:745) 但是我再1.8的环境下没有得到这种结果。原因是1.8 put的时候采用了“尾插法”避免了上面的问题，但是依然会有线程安全问题，会导致map.size()比实际数量少。 1234567891011121314public static void main(String[] args) throws InterruptedException { final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(8); for (int i = 0; i &lt; 10000; i++) { new Thread(new Runnable() { @Override public void run() { map.put(UUID.randomUUID().toString().substring(0,7), &quot;&quot;); } },String.valueOf(i)).start(); } Thread.sleep(1000); System.out.println(map.size()); } 结果得到的size&lt;10000。ps:1.8环境下arrayList的线程安全问题依然是’ConcurrentModificationException’。 12345678910111213public static void main(String[] args) { ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //List&lt;String&gt; list = Collections.synchronizedList(new ArrayList &lt;&gt;()); //List&lt;String&gt; list = new CopyOnWriteArrayList &lt;&gt;(); for (int i = 0 ; i &lt; 3 ; i++){ new Thread(() -&gt; { list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); },String.valueOf(i)).start(); } System.out.println(list.size()); } 问题二：1.7和1.8currentHashMap实现线程安全的思路1.7： 锁分段技术：segment 不同线程插入不同段中不会产生竞争，在put的代码中会先判断segment segment集成ReentrantLock,使用tryLock()+重试的方式获取锁，当超过重试次数时采用Lock()方式。 1.8： 改进一：同hashMap一样，改为了数组+链表+红黑树 放弃了原因的锁分段，采用CAS+synchronized：put方法在空位置插入的时候采用CAS，在有hash冲突的地方采用synchronize方式。 1.8 的扩容方法采用了两组变量来将扩容区分为前一次和后一次，两组指针来区分hash值求与的不同情况，但是不清楚为何要奥这样做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * @return the table */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; //新的容量值，新的扩容阀界值 int newCap, newThr = 0; //oldTab!=null,则oldCap&gt;0 if (oldCap &gt; 0) { //如果此时oldCap&gt;=MAXIMUM_CAPACITY(1 &lt;&lt; 30)，表示已经到了最大容量，这时还要往map中放数据，则阈值设置为整数的最大值 Integer.MAX_VALUE，直接返回这个oldTab的内存地址。 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //如果(当前容量*2&lt;最大容量&amp;&amp;当前容量&gt;=默认初始化容量（16）) //并将将原容量值&lt;&lt;1(相当于*2)赋值给 newCap else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //如果能进来证明此map是扩容而不是初始化 //操作：将原扩容阀界值&lt;&lt;1(相当于*2)赋值给 newThr newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold //进入此if证明创建map时用的带参构造：public HashMap(int initialCapacity)或 public HashMap(int initialCapacity, float loadFactor) //注：带参的构造中initialCapacity（初始容量值）不管是输入几都会通过 “this.threshold = tableSizeFor(initialCapacity);”此方法计算出接近initialCapacity参数的2^n来作为初始化容量（初始化容量==oldThr） newCap = oldThr; else { // zero initial threshold signifies using defaults //进入此if证明创建map时用的无参构造： //然后将参数newCap（新的容量）、newThr(新的扩容阀界值)进行初始化 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { //进入此if有两种可能 // 第一种：进入此“if (oldCap &gt; 0)”中且不满足该if中的两个if // 第二种：进入这个“else if (oldThr &gt; 0)” //分析：进入此if证明该map在创建时用的带参构造，如果是第一种情况就说明是进行扩容且oldCap（旧容量）小于16，如果是第二种说明是第一次put float ft = (float)newCap * loadFactor; //计算扩容阀界值 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果“oldTab != null”说明是扩容，否则直接返回newTab if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //如果该元素是TreeNode的实例 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null;//此对象接收会放在原来位置 Node&lt;K,V&gt; hiHead = null, hiTail = null;//此对象接收会放在“j + oldCap”（当前位置索引+原容量的值） Node&lt;K,V&gt; next; do { next = e.next; //在扩容之前已经存放K-V键值对是否还要重新计算并分配到扩容之后的HashMap中 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 注意扩容前桶中的结点分为两种，一种是依旧在之前那个桶对应的下标的桶中，另一种是之前所在的桶的下标+oldCap ，分开的条件是该结点的K的hash值与扩容之前的总桶数n做了一个&amp;运算（以前做映射的时候的公式为hash&amp;（n-1）n为总桶数注意两个公式区别），为什么要使用这个条件分为两个链表，主要是判断出扩容之后哪些结点依旧在之前那个桶对应的下标的桶中，哪些结点在之前所在的桶的下标+oldCap的桶中原理如下图https://blog.csdn.net/qq_36856024/article/details/99688530 https://blog.csdn.net/qq_36856024/article/details/99688530","link":"/2020/07/06/HashMap%E5%92%8CCurrentHashMap/"},{"title":"Maven IDEA Plugin-解决idea和maven相关问题.","text":"maven 命令中有idea编辑器相关命令，可以解决诸如：源码下载不下来，编译找不到相关jar包，无法识别子模块，maven项目迁移出现的各种问题（说到底，是idea的配置文件有问题，需要更新） 官网：http://maven.apache.org/plugins/maven-idea-plugin/ 主要命令介绍： The IDEA Plugin has five goals. idea:idea is used to execute the other three goals of this plugin: project, module, and workspace. idea:project is used to generate the project file (*.ipr) needed for an IntelliJ IDEA Project. idea:module is used to generate the module files (*.iml) needed for an IntelliJ IDEA Module. idea:workspace is used to generate the workspace file (*.iws) needed for an IntelliJ IDEA Project. idea:clean is used to delete the files relevant to IntelliJ IDEA. 使用： 1mvn idea:idea 今天就解决了一个在本机迁移maven仓库后，jar包找不到的问题。 1234Error:(23, 26) java: 程序包net.sf.cglib.proxy不存在Error:(67, 43) java: 找不到符号 符号: 类 Callback 位置: 类 org.apache.ibatis.executor.loader.cglib.CglibProxyFactory 看网上还能解决jar包下载不下来的问题。 1mvn -U idea:idea","link":"/2020/06/18/Maven-IDEA-Plugin-%E8%A7%A3%E5%86%B3idea%E5%92%8Cmaven%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"title":"Zookeeper小总结.md","text":"是什么 Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 文件系统+通知机制 文件系统：zookeeper借助于类似linux的文件系统的方式解决分布式系统的一系列问题。 通知机制：客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。 能干嘛（参考：1. atguigu 大数据技术Zookeeper。2：https://www.iteye.com/blog/ronghao-1461798 ） （统一）命名服务 统一配置管理 统一集群管理 服务器动态上下线 软负载均衡* 分布式锁：都是通过创建节点的方式来实现 保持独占 控制时序 队列管理 同步队列 先进先出 选举机制paxos算法 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致的问题。 节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。Paxos 算法就是一种基于消息传递模型的一致性算法。 Paxos算法的基本原理两个，一个是最终一致，另外一个是多数一致。（它保证CAP理论中的CP?) 扩展：活锁问题-选取主Proposer 参考 Paxos算法原理和过程解析 分布式协议与算法实战 - 5 Paxos算法 zookeeper选举实现 zookeeper ZAB协议的实现 选举分为初始化选举和服务器运行期间Leader的选举 两个关键变量 sid（myid)和zxid,先看zxid，再看sid。 投票数据结构、判断是否变更投票 参考：https://www.cnblogs.com/myseries/p/11285832.html 自定义选举算法zookeeper的选举算法是Election接口的lookForLeader方法，子类FastLeaderElection 实现了这个方法。zookeeper原先有三种选举算法来着，但是自某个版本以后只有这一种了。我们也不讨论这个选举算法实现，而是借此实现一个自己的lead选举。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Election extends Connect implements Watcher { private final static Logger LOGGER = LoggerFactory.getLogger(Election.class); private final static String nodePrefix = &quot;/node-&quot;; /*有序节点名*/ private String path; private String root; /*启动时进行选举，确认leader*/ public Election(String address, String root, String name) { super(address); try { this.root = formatRoot(root); if (zooKeeper.exists(this.root, false) == null) { zooKeeper.create(this.root, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } // 监控父节点 zooKeeper.getChildren(this.root, this); path = zooKeeper.create(this.root + nodePrefix, name.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); LOGGER.info(&quot;this node path is :{}&quot;, path); } catch (KeeperException | InterruptedException e) { e.printStackTrace(); } } /*格式化根节点的name*/ private String formatRoot(String root) { return root.startsWith(&quot;/&quot;) ? root : &quot;/&quot; + root; } /* 父节点变化时，重新进行leader选举*/ @Override public void process(WatchedEvent event) { try { List&lt;String&gt; children = zooKeeper.getChildren(root, this); long miniestNum = findMinima(children); String path = root.concat(nodePrefix).concat(StringUtils.leftPad(String.valueOf(miniestNum), 10, &quot;0&quot;)); Stat stat = zooKeeper.exists(path, false); byte[] data = zooKeeper.getData(path, false, stat); Stat statRoot = zooKeeper.exists(root, false); zooKeeper.setData(root, data, statRoot.getVersion()); System.out.println(new String(zooKeeper.getData(root, false, statRoot))); } catch (KeeperException | InterruptedException e) { e.printStackTrace(); } } /*找到最小的序列号*/ private Long findMinima(List&lt;String&gt; children) { List&lt;Long&gt; seqs = new ArrayList&lt;&gt;(); for (String child : children) { seqs.add(getNumber(child)); } Collections.sort(seqs); return seqs.get(0); } /*取nodeName中的数值*/ private long getNumber(String path) { String seq = path.substring(root.length() + nodePrefix.length()); return Long.parseLong(seq); }} public static void main(String[] args) { Election election = new Election(StaticUtils.ZK_ADDRESS, &quot;myapp&quot;, &quot;d&quot;); // 模拟应用服务中 LockSupport.park(); } ps：（原先zoo.cfg中配置的三种算法） 1 对应：LeaderElection 算法。 2 对应：AuthFastLeaderElection 算法。 3 对应：FastLeaderElection 默认的算法。 ZAB协议（ Zookeeper Atomic Broadcast）简单介绍：https://www.jianshu.com/p/400a44edee88 详细介绍：https://www.jianshu.com/p/2bceacd60b8a这里摘录一点内容： 主备模型：Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交 核心：定义事务请求的处理方式：Leader_follewer-Proposal-板书Follower正确反馈 两种基本的模式：崩溃恢复 和 消息广播 消息广播：Leader和每个Follwer之间维护一个消息异步队列；半数以上即可提交 崩溃恢复：Leader选举 和 数据恢复 ZAB协议如何保证数据一致性 Zab 协议崩溃恢复要求满足以下两个要求： 1）确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交。 2）确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal。根据上述要求 Zab协议需要保证选举出来的Leader需要满足以下条件： 1）新选举出来的 Leader 不能包含未提交的 Proposal 。 即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点。 2）新选举的 Leader 节点中含有最大的 zxid 。 这样做的好处是可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。 监听器简单来讲就是ZkClient创建两个线程，Connect负责建立链接，将Listener注册到Zk中，Listener负责接收变化。（未完待续） 参考： atguigu 大数据技术Zookeeper-监听器原理 示例 https://blog.csdn.net/qq_33598343/article/details/83927731 推荐https://github.com/llohellohe/llohellohe.github.com/tree/master/readers/ZooKeeper","link":"/2020/07/11/Zookeeper%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"title":"bat命令学习","text":"基础部分一、介绍 批处理文件是一个“.bat”结尾的文本文件，这个文件的每一行都是一条DOS命令。可以使用任何文本文件编辑工具创建和修改。 批处理是一种简单的程序，可以用 if 和 goto 来控制流程，也可以使用 for 循环。 批处理的编程能力远不如C语言等编程语言，也十分不规范。 每个编写好的批处理文件都相当于一个DOS的外部命令，把它所在的目录放到DOS搜索路径(path)中，即可在任意位置运行。 C:\\AUTOEXEC.BAT 是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。 大小写不敏感(命令符忽略大小写) 批处理的文件扩展名为 .bat 或 .cmd。 在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用cmd.exe来运行该文件。 二、参数 系统参数 %SystemRoot% === C:\\WINDOWS (%windir% 同样) %ProgramFiles% === C:\\Program Files %USERPROFILE% === C:\\Documents and Settings\\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等) %APPDATA% === C:\\Documents and Settings\\Administrator\\Application Data %TEMP% === C:\\DOCUME~1\\ADMINI~1\\LOCALS~1\\Temp (%TEM% 同样) %APPDATA% === C:\\Documents and Settings\\Administrator\\Application Data %OS% === Windows_NT (系统) %Path% === %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem (原本的设置) %HOMEDRIVE% === C: (系统盘) %HOMEPATH% === \\Documents and Settings\\Administrator :: 枚举当前的环境变量 setlocal enabledelayedexpansion FOR /F &quot;usebackq delims==&quot; %%i IN (`set`) DO @echo %%i !%%i! 传递参数给批处理文件%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。Sample： call test2.bat &quot;hello&quot; &quot;haha&quot; (执行同目录下的“test2.bat”文件，并输入两个参数) 在“test2.bat”文件里写: echo %1 (打印: &quot;hello&quot;) echo %2 (打印: &quot;haha&quot;) echo %0 (打印: test2.bat) echo %19 (打印: &quot;hello&quot;9) 批处理基本命令 help命令(/?)语法： 命令 /?可显示此命令的帮助信息 type /? &gt;&gt;tmp.txt (把 type 命令的帮助信息写入到tmp.txt文件里) help type (显示跟“type /?”一样) echo命令语法: echo [on|off] [message]ECHO [ON | OFF] 打开回显或关闭回显功能。ECHO 显示当前回显设置。ECHO [message]显示信息。echo off 表示在此语句后所有运行的命令都不显示命令行本身；默认是on，on时会显示如： C:\\文件夹路径&gt;命令行。在实际应用中我们会把这条命令和重定向符号( 也称为管道符号，一般用 &gt; &gt;&gt; ^ )结合来实现输入一些命令到特定格式的文件中。sample1: F:\\&gt;echo hello world hello world F:\\&gt;echo on F:\\&gt;echo helloworld helloworld F:\\&gt;echo off echo helloworld helloworldsample2: echo Windows Registry Editor Version 5.00 &gt; c:\\setupreg.reg (此前还没有 setupreg.reg 这个文件) echo &quot;SourcePath&quot;=&quot;D:\\\\Win2003\\\\&quot; &gt;&gt; c:\\setupreg.reg (追加内容进 setupreg.reg 这个文件) @命令表示不显示@后面的命令，(在入侵过程中自然不能让对方看到你使用的命令啦)@ 与 echo off 相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行(只能影响当前行)。 @echo off (此语句常用于开头，表示不显示所有的命令行信息，包括此句) @echo please wait a minite... Rem命令语法：Rem Message…(小技巧：用::代替rem)注释命令，在C语言中相当与/…/,它并不会被执行，只是起一个注释的作用，便于别人阅读和自己日后修改。 goto命令语法：goto label (label是参数，指定所要转向的批处理程序中的行。)指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。label标签的名字可以随便起，但是最好是有意义的，字母前必须加个冒号“:”来表示这个字母是标签。goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if 配合使用，根据不同的条件来执行不同的命令组。 Pause 命令会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续sample: @echo off :begin copy a:*.* d:\\back echo Please put a new disk into driver A pause goto begin在这个例子中，驱动器 A 中磁盘上的所有文件均复制到d:\\back中。显示的信息提示您将另一张磁盘放入驱动器 A 时，pause 命令会使程序挂起，以便您更换磁盘，然后按任意键再次复制。 call 命令语法: call [[Drive:][Path] FileName [BatchParameters]] [:label [arguments]]参数: [Drive:][Path] FileName 指定要调用的批处理程序的位置和名称。filename 参数必须具有 .bat 或 .cmd 扩展名。调用另一个批处理程序，并且不终止父批处理程序。如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用 call，它将不会在命令行起作用。 call=&quot;%cd%\\test2.bat&quot; haha kkk aaa (调用指定目录下的 test2.bat，且输入3个参数给他) call test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他)注：可以调用自身(死循环、递归) start 命令调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令 来调用。常用参数： MIN 开始时窗口最小化 SEPARATE 在分开的空间内开始 16 位 Windows 程序 HIGH 在 HIGH 优先级类别开始应用程序 REALTIME 在 REALTIME 优先级类别开始应用程序 WAIT 启动应用程序并等候它结束 parameters 这些为传送到命令/程序的参数 start /MIN test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他，且本窗口最小化) e:\\&quot;program files&quot;\\极品列车时刻表\\jpskb.exe (文件路径名有空格时) if else IF语法: if [not] “参数” == “字符串” 待执行的命令参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号) if &quot;%1&quot; == &quot;a&quot; format a: if {%1} == {} goto noparms if exist语法: if [not] exist [路径]文件名 待执行的命令如果有指定的文件，则条件成立，运行命令，否则运行下一句。 if exist config.sys edit config.sys (表示如果存在这文件，则编辑它) if exist config.sys type config.sys (表示如果存在这文件，则显示它的内容) if errorlevel number语法: if [not] errorlevel &lt;数字&gt; 待执行的命令如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列) @echo off XCOPY F:\\test.bat D:\\ IF ERRORLEVEL 1 (ECHO 文件拷贝失败 ) Else IF ERRORLEVEL 0 ECHO 成功拷贝文件 pause很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。常见的返回码为0、1。通过if errorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。 else语法： if 条件 (成立时执行的命令) else (不成立时执行的命令)如果是多个条件，建议适当使用括号把各条件包起来，以免出错。 if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) else (echo comment3 )注：如果 else 的语句需要换行，if 执行的行尾需用“^”连接，并且 if 执行的动作需用(括起来)，否则报错 if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) ^ else (echo comment3 ) 比较运算符:EQU - 等于 (一般使用“==”)NEQ - 不等于 (没有 “!=”,改用“ if not 1==1 ”的写法)LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于 choice 命令choice 使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的 errorlevel，然后配合 if errorlevel 选择运行不同的命令。注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234…… choice /c:dme /m defrag,mem,end if errorlevel 3 goto defrag (应先判断数值最高的错误码) if errorlevel 2 goto mem if errotlevel 1 goto end for命令1) for {%variable | %%variable} in (set) do command [command-parameters]%variable 指定一个单一字母可替换的参数。变量名称是区分大小写的，所以 %i 不同于 %I在批处理文件中使用 FOR 命令时，指定变量建议用 %%variable而不要用 %variable。 注意：在批处理文件中使用%%,命令行显示为%,命令行中要使用一个%,使用%%会报错 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 rem 如下命令行会显示当前目录下所有以bat或者txt为扩展名的文件名。 for %%c in (*.bat *.txt) do (echo %%c) 2) 如果命令扩展名被启用，下列额外的 FOR 命令格式会受到支持: FOR /D %variable IN (set) DO command [command-parameters] 如果set集里面包含通配符，则指定与目录名匹配，而不与文件名匹配。 rem 如下命令行会显示当前目录下所有包含有 e 或者 i 的目录名。 for /D %%a in (*e* *i*) do echo %%a FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。 如果在 /R 后没有指定目录，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。 rem 如下命令行会显示 E盘test目录 下所有以bat或者txt为扩展名的文件名。 for /R E:\\test %%b in (*.txt *.bat) do echo %%b for /r %%c in (*) do (echo %%c) :: 遍历当前目录下所有文件 FOR /L %variable IN (start,step,end) DO command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。 如：(1,1,5) 将产生序列 1 2 3 4 5； 而(5,-1,1) 将产生序列 (5 4 3 2 1)。 rem 如下命令行将产生序列 1 2 3 4 5 for /L %%c in (1,1,5) do echo %%c 有或者没有 usebackq 选项: FOR /F [&quot;options&quot;] %variable IN (file-set) DO command FOR /F [&quot;options&quot;] %variable IN (&quot;string&quot;) DO command FOR /F [&quot;options&quot;] %variable IN (command) DO command 参数”options”为: eol=c - 指一个行注释字符的结尾(就一个,如“;”) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。m-n格式为一个范围。如果符号字符串中的最后一个字符为星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 filenameset中使用双引号扩起文件名称。 以下两句，显示当前的年月日和时间 For /f &quot;tokens=1-3 delims=-/. &quot; %%j In (&apos;Date /T&apos;) do echo %%j年%%k月%%l日 For /f &quot;tokens=1,2 delims=: &quot; %%j In (&apos;TIME /T&apos;) do echo %%j时%%k分 把记事本中的内容每一行前面去掉8个字符 setlocal enabledelayedexpansion for /f %%i in (zhidian.txt) do ( set atmp=%%i set atmp=!atmp:~8! if {!atmp!}=={} ( echo.) else echo !atmp! ) :: 读取记事本里的内容(使用delims 是为了把一行显示全,否则会以空格为分隔符) for /f &quot;delims=&quot; %%a in (zhidian.txt) do echo.%%a 注： setlocal enabledelayedexpansion开启扩展参数延迟，将在后面讲解。 ~8意思为从字符串的第8个字符开始截取，有关字符串截取在后面讲解。 经过试验，注释部分会读取错误，截取纯文本没有问题，但是当截取含有特殊符号的文本时（比如本文中上面一段）并没有得到想要的结果，不知为何。 3) continue 和 break 利用 goto 实现程序中常用的 continue 和 break 命令, 其实非常简单 continue: 在 for 循环的最后一行写上一个标签，跳转到这位置即可 break: 在 for 循环的外面的下一句写上一个标签，跳转到这位置即可 for /F [&quot;options&quot;] %variable IN (command) DO ( ... do command ... if ... goto continue if ... goto break ... do command ... :continue ) :break 三、其它命令 ping 命令测试网络联接状况以及信息包发送和接收状况。但是不能够测试端口。 语法：ping IP地址或主机名 [-t] [-a] [-n count] [-l size]参数含义： -t 不停地向目标主机发送数据；-a 以IP地址格式来显示目标主机的网络地址；-n count 指定要Ping多少次，具体次数由count来指定；-l size 指定发送到目标主机的数据包的大小。 ping 192.168.0.1 -t (不停的测试192.168.0.1，按ctrl+c停止) for /L %%a in (0,1,255) do ping 192.168.0.%%a -n 1 &gt;&gt; tmp.txt (ping一下所有的局域网电脑) telnet 命令测试端口使用 telnet IP地址或主机名 端口，使用tcp协议的 telnet 192.168.0.1 80 (测试192.168.0.1的80端口) color 命令设置背景及字体颜色 语法： color bfb 是指定背景色的十六进制数字； f 指定前景颜色(即字体颜色)。颜色值: 0:黑色 1:蓝色 2:绿色 3:湖蓝 4:红色 5:紫色 6:黄色 7:白色 8:灰色 9:淡蓝 A:淡绿 B:浅绿 C:淡红 D:淡紫 E:淡黄 F:亮白如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时的颜色。如果两参数一样，视为无效输入。只有一个参数时，设置字体。 random 命令产生随机数(正整数0~)，要使用random，必须将其当作一个变量来使用，这样才能得到值。 echo %random%%random%可以产生0到65535之间的随机数。通过获得一定范围内的随机数：通用的算法公式如： %random%%%(max-min+1)+min来产生[min,max]区间里的随机数注：批处理中求模得用两个%%符号。 @REM 产生10个[4,12]间的随机数 @echo off REM 启用延迟环境变量扩展 setlocal enabledelayedexpansion REM 设置随机数的最小和最大值以及求模用的变量 set min=4 set max=12 set /a mod=!max!-!min!+1 for /l %%i in (1,1,10) do ( REM 产生[min,max]之间的随机数 set /a r=!random!%%!mod!+!min! echo. echo 随机数%%i：!r! )参考链接 exit 命令结束程序。即时是被调用的程序，结束后也不会返回原程序 shutdown命令shutdown -s 关机 所有内置命令的帮助信息ver /?cmd /?set /?rem /?if /?echo /?goto /?for /?shift /?call /?其他需要的常用命令type /?find /?findstr /?copy /? 四、字符串处理 分割字符串，以查看时间为例%源字符串:~起始值,截取长度% (起始值从0开始；截取长度是可选的，如果省略逗号和截取长度，将会从起始值截取到结尾；截取长度如果是负数，表示截取到倒数第几个。) &quot;%time%&quot; 显示如：&quot;11:04:23.03&quot; (完整的时间&quot;hh:mm:ss.tt&quot;) &quot;%time:~0,5%&quot; 显示&quot;hh:mm&quot;(即&quot;11:04&quot;)，其中0表示从右向左移位操作的个数，5表示从左向右移位操作的个数 &quot;%time:~0,8%&quot; 显示标准时间格式&quot;hh:mm:ss&quot;(即&quot;11:04:23&quot;，前8个字符串) &quot;%time:~3,-3%&quot;显示&quot;mm:ss&quot;(即从第4个开始,截去最后3个的字符串) &quot;%time:~3%&quot; 显示&quot;04:23.03&quot;(即去掉前4个字符串) &quot;%time:~-3%&quot; 显示&quot;.tt&quot;(即最后3个字符串)上面的字串分割格式，也可以用于其它地方，如目录路径：”%cd:~0,10%” 替换字符串 set a=&quot;abcd1234&quot; echo %a% 显示：&quot;abcd1234&quot; set a=%a:1=kk% 替换“1”为“kk” echo %a% 显示：&quot;abcdkk234&quot; 字符串合并 set str1=%str1%%str2% (合并 str1 和 str2) 计算字符串长度没有现成的函数。如下程序利用 goto形成循环，不断将字符串截短1，并记录截短的次数，到字符串变成空时的次数即长度。 set testStr=This is a test string :: 将 testStr 复制到str，str 是个临时字符串 set str=%testStr% :: 标签，用于goto跳转 :next1 :: 判断str是不是空，如果不是则执行下边的语句 if not &quot;%str%&quot;==&quot;&quot; ( :: 算术运算，使num的值自增1，相当于num++或者++num语句 set /a num+=1 :: 截取字符串，每次截短1 set &quot;str=%str:~1%&quot; :: 跳转到next1标签: 这里利用goto和标签，构成循环结构 goto next1 ) :: 当以上循环结构执行完毕时，会执行下边的语句 echo testStr=%testStr% echo testStr的长度为：%num% 截取字符串时，需要传递参数直接 echo %args:~%num%,-5% 没办法想要的字符串，需要如下两步 setlocal enabledelayedexpansion echo !args:~%num%,-5! 五、系统服务 停止服务：NET STOP 服务名启动服务：NET Start 服务名 设置启动类型自动： SC CONFIG 服务名 START= auto手动： SC CONFIG 服务名 START= demand已禁用：SC CONFIG 服务名 START= disabled附：“START= ”等号后面必须要有一个空格。(start还有boot,system两个值)Sample: SC CONFIG Spooler START= demand (打印机加载项，设置成手动，默认自动) 查看系统服务：start %SystemRoot%\\system32\\services.msc /s 六、setlocal与变量延迟 批处理中setlocal enabledelayedexpansion的含义参考链接注意两点： 什么叫环境变量扩展和延迟环境变量扩展 延迟的变量用！！表示 启动批处理文件中环境变量的本地化。本地化将持续到出现匹配的 endlocal 命令或者到达批处理文件结尾为止。语法: setlocal {enableextension | disableextensions} {enabledelayedexpansion | disabledelayedexpansion}enableextension: 启用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。disableextensions: 禁用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。enabledelayedexpansion: 启用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。disabledelayedexpansion: 禁用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 七、文件处理 删除 删除一个文件或多个文件del /s /q /f d:\\test\\a.bat将直接删除d:\\test\\a.bat，没有任务提示del temp* /q /f /s将直接删除 本目录的 temp 目录的所有文件，没有任务提示删除文件的时候可以使用“*”作通配符 删除一个空目录rd /q /s d:\\test\\log将直接删除d:\\test\\log目录，如果log目录里面有文件将无法删除 删除一个非空目录 (必须指定目录名称)rmdir /q /s d:\\test\\logs必须指定目录名称，不能使用通配符/S 除目录本身外，还将删除指定目录下的所有子目录/Q 安静模式，带 /S 删除目录树时不要求确认无论里面是否有文件或文件夹将全部直接删除 创建目录MKDIR [drive:]pathMD [drive:]path路径有空格时，可以用双引号括起来，也可以用 &nbsp; 替代 实践部分1.小摘录 调用其他程序时，对文件的大小写不敏感，文件后缀也可忽略如：start LeapFTP.exe 与 start leapftp 效果一样，都是运行“LeapFTP.exe”文件 每行的开头的字符串会自动查找程序来运行，还可用双引号引起来(文件名或目录名含空格时必须用)如：”D:\\Program Files\\Leap FTP.exe”“LeapFTP.exe” 可正常运行文件（在原窗口）start “标题” “LeapFTP.exe” start是在新窗口运行(第一个参数是窗口显示的标题) copy C:\\test*.* D:\\back (复制C盘test文件夹的所有文件(不包括文件夹及子文件夹里的东西)到D盘的back文件夹) dir c:*.* &gt; a.txt (将c盘文件列表写入 a.txt 中) &gt; 生成文件并写入内容(如果有这文件则覆盖)， &gt;&gt; 文件里追加内容 md d:\\aa (创建文件夹) 在命令末尾加上“&gt;NUL 2&gt;NUL”，表示隐蔽返回信息。 等待用户输入： set /p 变量名=屏幕显示信息。set是对参数的定义，动态的话需要加上/p的条件，“=”后面的内容便是对这个参数的描述，在用户需要输入值得时候提示用户。 set /p a=请输入a: set /p b=请输入b: echo %a% %b% pause&gt;nul 让用户按回车退出小技巧(替代pause)，文件的最后一句：set /p tmp=操作结束，请按回车键退出… 设置标题： title JDK安装 清屏： cls 修改文件的更新日期copy 文件名+‘’&gt;nul (修改为当前时间，如果要修改为指定时间，先修改系统时间，再改回系统时间) 修改文件的后缀名ren C:\\test*.jpg .JPGfor /r %%c in (.jpg) do (ren %%c *.JPG) :: 修改当前目录下的所有文件的后缀名，包括子目录的 修改文件的文件名rename test.jpg test2.JPGrename *.jpg *.888.JPG 共享A.查看你机器的共享资源: net shareB.手工删除共享 net share 共享资源名称$ /d 注意$后有空格。C.增加一个共享： net share mymovie=e:\\downloads\\movie /users:3 mymovie 共享成功。 同时限制链接用户数为3人。 实例收集 在批处理中使用密码。密码为admin，输入正确，跳转到next1 ，若输入密码错误3次，则锁屏。。 @echo off set num=0 :11 set /p pass=请输入密码: if &quot;%pass%&quot;==&quot;admin&quot; goto next1 set /a num=%num% + 1 if %num%==3 goto no1 goto 11 :no1 %windir%\\system32\\rundll32.exe user32.dll,LockWorkStation goto 11 :next1 echo 密码正确，执行下面的程式 pause 坑 部分命令直接在cmd窗口中运行不了，要写入.bat文件中运行 网上查询的或者实例中的命令运行不了，提示”XXX不是有效命令”。–原因是我把系统默认的记事本编辑器改为notepad了，用notpad编辑的bat文件，每行的头部少一些东西吧。当我重新建一个bat文件，用sublimetext打开编辑的时候，就好了（不要问我为何不用系统记事本233333~）。另外注意编码格式要选择GBK或者ANSI，否则会有中文乱码问题。 参考链接：Bat命令学习","link":"/2018/10/13/bat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"},{"title":"U2-java内存区域与内存溢出异常","text":"1. 运行时数据区Java虚拟机运行时所管理的内存主要包括以下几个区域： 程序计数器 虚拟机栈 本地方法栈 堆 方法区 程序计数器当前线程所执行的字节码的行号指示器，线程私有的。 虚拟机栈 线程私有，“描述方法执行的内存模型”,栈帧创建和销毁–方法调用到完成。 Java内存分为 堆-栈，栈–虚拟机栈-局部变量表：基本数据类型，对象的引用，returnAddress。 long,double类型数据占用两个局部变量空间(Slot)，其余占用一个Slot，局部变量表在编译时分配内存空间–方法需要在帧中分配的局部变量空间是确定的。 线程请求栈深度大于虚拟机所允许的深度：StackOverflowError;虚拟机栈扩展时无法申请到足够内存：OutOfMemoryError 本地方法栈为虚拟机用的的Native方法服务，与虚拟机栈类似(线程私有) 堆线程共享，存放对象实例和数组，垃圾收集主要区域：GC堆，物理上不连续逻辑上连续即可。 方法区 线程共享，存放类信息、常量、静态变量和即时编译器编译 后的代码，逻辑上为堆的一部分，别名：非堆（Non-Heap）. HotSpot虚拟机把方法区称为”永久代”-GC分代收集扩展至方法区–不是一个好方法 方法区的数据不是永久存在，数据回收主要针对常量池的回收和类型卸载。 运行时常量池 方法区的一部分，存放编译期间生产的字面量和符号引用（？），直接引用。 运行期间也可以将新的常量放入池中。例：String的intern()方法。 直接内存NIO中基于通道(Channel)和缓冲区(Buffer)的I/O方式可以使用Native函数库直接分配堆外内存/系统内存。 2. HotSpot虚拟机对象探秘对象的创建 new执行能否在常量池中定义到一个类的符号引用，确认这个类是否被加载，解析和初始化。 为新对象分配内存空间：指针碰撞方法和空闲列表方法–Java堆是否规整–垃圾收集器是否带有压缩整理算法(Compact) 并发情况下的线程安全问题： 对分配内存空间的动作进行同步处理–CAS+失败重试保证更新操作原子性 内存分配动作按照线程划分在不同空间之中进行–TLAB本地线程分配缓冲：-XX:+/-UseTLAB参数 初始化零值–设置对象头–init 对象的内存布局对象头(Header)，实例数据(Instance Data)，填充信息(Padding) header: 存储对象自身的运行时数据-Mark Word（对象在不同状态下Mark Word存储内容不同） 类型指针 数组–记录长度的数据 Instance Data: Padding: HotSpot要求对象起始地址必须为8字节的整数倍 对象的访问定位 使用句柄 直接指针 3. OutOfMemoryError异常小总结 java堆溢出 内存泄漏(Memory Leak):对象没有被引用了，但是没有被垃圾回收，导致堆内存不够用。 内存溢出(Memory Overflow)：内存中对象必须存活，但是对象太多导致堆内存不够用。 通过参数-XX:+HeapDumpOnOutOfMemoryError查看虚拟机在出现内存溢出时Dump出的当前内存的堆转储快照来分析。分析工具：Memory AnalyzerMemory Analyzer使用：https://blog.csdn.net/wizard_rp/article/details/73266194https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html内存泄漏可以分析原因，内存溢出可以考虑调整虚拟机参数加大内存或者检查代码减少运行内存占用。 虚拟机栈和本地方法栈溢出 StackOverflowError异常 public class JavaVMStackOf { private int stacklength = 1; public void stackLeak(){ stacklength++; stackLeak(); } public static void main(String[] args) { JavaVMStackOf javaVMStackOf = new JavaVMStackOf(); try { javaVMStackOf.stackLeak(); } catch (Exception e) { System.out.println(javaVMStackOf.stacklength); } } } OutOfMemoryError异常一般由多线程导致，且不容器找到原因。（代码由于在本机运行时死机消失了，懒得贴出了） 方法区和运行时常量池异常 public class RuntimeConstantPoolOOM { public static void main(String[] args) { /*List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while(true){ list.add(String.valueOf(i++).intern()); }*/ String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;r&quot;).toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString(); System.out.println(str2.intern() == str2); } } 由于jdk1.7将运行时常量池移出了方法区，所有加/**/代码运行时不会出现异常。 未加注释的段落jdk1.6运行结果false false,jdk1.7结果为true false。intern()方法在1.7中不再会复制首次出现的字符串实例，而是在常量池中记录首次出现额实例的引用。 本机直接内存溢出 public class DirectMemoryOOM { private static final int _1MB = 1024*1024; public static void main(String[] args) { Field field = Unsafe.class.getDeclaredFields()[0]; field.setAccessible(true); try { Unsafe unsafe = (Unsafe)field.get(null); while(true){ unsafe.allocateMemory(_1MB); } } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 如果Heap Dump文件没有明显异常，OOM后dump文件很小，程序中直接或间接使用了NIO，可以考虑这方面原因。","link":"/2018/11/18/U2-java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"},{"title":"lock与synchronized的区别-自总结-底层","text":"synchronized与lock的区别synchronized 是Java的关键字，在虚拟机层面，它通过monitorenter和monitorexit指令来实现虚拟机的lock和unlock原子性操作，但是需要持有一个特定的锁。lock是java concurrent包下的接口。用它来做锁操作主要可以实现 可控制中断、可实现公平锁、可绑定多个条件的特性。另外，synchronized和lock都是可重入锁 lock是一个接口，我们看下Reetranklock的实现123public void lock() { sync.lock(); } 他有公平和非公平两种实现公平锁：如果不满足条件就自我中断12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 非公平锁123456789101112131415161718static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } 再具体的原理现在还没弄清楚，可以参考下面的链接https://www.cnblogs.com/onlywujun/articles/3531568.htmlhttps://www.jianshu.com/p/f23caf038963 补充的一点是，java1.6之前lock是比syn的效率高的。但是在1。6及以后经过锁优化之后，两者效率差不多了。锁优化包括：自旋与自适应、锁消除、锁粗话、轻量级锁、偏向锁。所以在1.6以后，选择lock的原因只能是要实现更多的功能，而不是效率问题。 lock底层实现的总结上面的两个链接结合着看，可以大概对lock的实现有所了解。另外，推荐了解一下锁优化的内容，更有利于体会lock的设计。 准备知识(链接2) unsafe提供的两个关键机制 CAS，CPU提供的原子指令 park/unpark， 调用这个native函数会将线程调度和停止调度 unsafe不能被直接调用，可被虚拟机代码调用-&gt; LockSupport封装了这两个机制。 AbstractQueueSychronizer中间类，继承这个类可以实现各种EOF场景。EOF- 异常控制流程理解AbstractQueueSychronizer的关键 数据结构，使用的最简单的双向链表 操作系统底层，就是上面介绍的LockSupport封装 控制逻辑，主要是通过state和Node中的waitState控制的 理解lock接口 – ReetrantLock实现类 - Sync - fair,Nonfair TODO: CLH队列（自旋？） Sync.nonfairTryAcquire 可重入（+1操作），偏向锁 AbstractQueuedSynchronizer.addWaiter：通过CAS把当前现在追加到队尾，并返回包装后的Node实例 - NODE对象 AbstractQueuedSynchronizer.acquireQueued 解锁解锁代码主要体现在AbstractQueuedSynchronizer.release和Sync.tryRelease方法中 小总结:公平锁和非公平锁的区别只是在获取锁的时候代码有点区别，其它的都是一样的。公平锁和非公平锁只是在入AQS的CLH队列之前有所差别，一旦进入了队列，所有线程都是按照队列中先来后到的顺序请求锁。非公平锁的代码中总是优先尝试当前是否有线程持有锁，一旦没有任何线程持有锁，那么非公平锁就霸道的尝试将锁“占为己有”。（代码上面已经给出） 延伸并发的知识了解到这里已经可以知道冰山上面不止一角了，下面有庞大的体系了。再往下学一是要了解各种锁及实现，可以找一门课看看，二是要了解操心系统或者虚拟机对Java关键字的实现了。","link":"/2020/06/16/lock%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%87%AA%E6%80%BB%E7%BB%93-%E5%BA%95%E5%B1%82/"},{"title":"U3-垃圾收集器和内存分配策略","text":"本章讨论的垃圾收集和内存回收都是发生在堆和方法区的。 对象已死吗这里主要讲如何判断一个对象的死亡 引用计数算法时给对象添加一个引用计数器，每当有地方引用它，计数器值加一，引用失效时，计数器值减一；当计数器值为0的对象就是不能再被使用的。问题：解决不了对象之间循环引用的问题。 可达性分析算法从一系列称为“GC Roots”的根节点开始往下搜索，当一个对象到“GC Roots”没有任何引用链时，此对象不可用。GC Roots： 虚拟机栈（栈中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（即一般所说的native方法）引用的对象 引用（reference）JDK1.2以前定义：如果一个refenrece类型数据中的数值代表另一块内存的地址，我们就称它为引用类型的数据缺点：太过狭隘，我们希望能够描述这样的一类对象-内存空间足够则保留在内存中，不够则被回收。JDK1.2以后： 强引用（Strong Reference）：普通意义上的引用，例如：Object obj = new Object(); 软引用（Soft Reference）：内存足够时存在，不够时回收 Object obj = new Object(); SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj); obj = null; sf.get();//有时候会返回null 弱引用（Weak Reference）：被弱引用的对象只能存活到下一次垃圾收集之前 Object obj = new Object(); WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj); obj = null; wf.get();//有时候会返回null wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 虚引用（Phantom Reference）：唯一目的：在这个对象被收集器回收时得到一个系统通知。对象的虚引用不对其生存时间构成影响，也无法通过虚引用获得一个对象。 Object obj = new Object(); PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj); obj=null; pf.get();//永远返回null pf.isEnQueued();//返回是否从内存中已经删除 finalize()方法对象死亡的过程：可达性分析发现没有GC Roots引用链——第一次标记筛选：是否有必要执行finalize()方法—— 对象没有覆盖finalize()方法或者该方法已被执行——对象死亡 需要执行finalize()方法：进入 F-Queue队列，由Finalizer线程执行——进行第二次标记——如果对象在finalize()方法中拯救了自己（成功与引用链上的对象关联即可），则可以再次存活，否则死亡。注意：一个对象的finalize()方法只会执行一次。最好不要使用这个方法。 回收方法区永久代主要回收废弃常量和无用的类。判断无用的类必须同时满足： 该类所有实例已经被回收 加载该类的类加载器已经被回收 该类对应的java.lang.class对象没有在任何地方被引用，无法通过反射访问该类的方法 垃圾收集算法 标记清除（Mark-Sweep）标记需要回收的对象，标记完成后统一回收。问题：效率低，产生不连续内存碎片 复制算法将内存分为相等的两块，每次使用一块，垃圾回收时将可用对象复制到另一块内存上。确定：内存缩小一半，代价太高现代商业虚拟机做法： 整个堆内存分为新生代和老年带 在新生代将内存分为一个Eden区和两个survivor区-8：1：1 每次使用一个Eden区和一个survivor区，垃圾回收时将存活对象复制到另外一个survivor区 如果survivor不够用，则使用老年代进行分配担保 标记整理（Mark-Compact） 老年代使用的算法与标记清除类似，但是后续步骤不是直接清理，而是将可用对象都向一端移动，然后清理到边界以外的内存4. 分代收集算法将Java分为新生代和老年代，新生代采用复制算法，老年代采用标记清除或者标记整理算法。 HotSpot的算法实现 枚举根节点GC Roots 节点找引用链这个操作：不可能逐个检查所有引用，GC时其它线程必须停止工作，保证分析过程中对象引用的关系不发生变化。虚拟机有办法直接得知那些地方存放着对象的引用：HotSpot使用OoMap的数据结构来达到目的。在类加载的时候就把对象在什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会记录下栈和寄存器哪些位置是引用 安全点（SafePoint）不能为每一条指令都生成Oomap记录，只有在特定位置（安全点）才生成OoMap，程序执行时到达安全点才进行GC。安全点的选定：以“是否具有让程序长时间执行的特征”为标准–指令的复用：方法调用，循环跳转，异常跳转等。。。如果让GC发生时所用线程都跑到最近的安全点上停下： 抢先式中断：所有线程停下，发现不在安全点上的恢复，让其执行到安全点 主动式中断：设置标志，线程轮询，主动挂起。标志的地方与安全点重合 安全区域（Safe Region）解决线程不执行（没有分配CP=时间）时进入GC的问题。安全区域：一段代码中引用关系不会发生变化的区域，在这个区域的任意位置开始GC都是安全的。过程：线程执行到Safe Region时标准自己进入Safe Region了，JVM要执行GC时不对进入Safe Region的线程进行检查。当线程出Safe Region时检查是否已经完成枚举根节点（或者整个GC）操作，如果完成则继续执行，否则等待。 垃圾收集器HotSpot虚拟机的垃圾收集器 Serial收集器最基本的新生代收集器，进行垃圾收集时，必须暂停其它所有的工作线程。（stop the world）虚拟机client模式下默认的新生代收集器 ParNew收集器新生代收集器，Serial的多线程版本。Server模式下虚拟机首选的新生代收集器。原因是除了Serial外，目前（jdk1.7 u40 update）只有它能和CMS收集器配合工作。CMS无法与Parallel Scavenge收集器配合工作。单CPU环境下工作效率不比Serial New好多少，多CPU下表现良好。垃圾收集器上下文语境中并发与并行的概念 ： 并行： 多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态。 并发： 用户线程与垃圾收集线程同时执行（可能会交替执行），用户线程在继续运行，而垃圾收集线程运行在另外一个CPU上。 Parallel Scavenge收集器同ParNew一样采用复制算法的新生代收集器。CMS关注“尽可能缩短垃圾收集时用户线程的停顿时间”，Parallel Scavenge关注“达到一个可控制的吞吐量”，适用于后台运算而不需要太多交互任务。吞吐量：CPU用于运行用户代码的时间与CPU总耗时的比值。XX:+UseAdaptiveSizePolicy–GC自适应调节策略。 Serial Old收集器Serial收集器的老年代版本，client模式下的虚拟机使用。Server模式下-jdk1.5版本与Parallel Scavenge配合使用；作为CMS收集器的后备预案 Parallel Old收集器Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法。解决了Parallel Scavenge+Serial Old吞吐量还不如ParNew+CMS的组合。吞吐量优先的环境下，可以使用Parallel Scavenge+Parallel Old收集器 CMS（Concurrent Mark Sweep）收集器获取最短回收停顿时间，服务端，基于标记清除算法。过程： 初始标记：标记一下GC Roots能直接关联到的对象 并发标记：进行GC Roots Tracing 重新标记：修正并发标记阶段因用户程序运行导致标记产生变动的对象的标记记录 并发清除 如图缺陷： 对CPU资源非常敏感：CPU数量小于4个的时候，影响明显。 无法处理浮动垃圾：并发清除阶段用户线程产生的垃圾叫浮动垃圾。CMS收集器需要预留一部分空间供并发的用户线程使用，无法等到老年代全部填满再进行垃圾收集。JDK1.6中阈值提高到92%。CMS运行期间预留内存无法满足需求–Concurrent Mode Failure–临时启用Serial Old进行老年代收集。 产生大量空间碎片： +UseCMSCompactAtFullCollection进行碎片合并整理。 G1（Garbage First）收集器特点： 并行与并发：仍然有利用多核CPU的特点 分代收集 空间整合：整体来看基于标记-整理算法，局部（两个Region之间）基于复制算法 可预测的停顿：让使用者指定在M毫秒的时间片内，垃圾收集时间不超过Ｎ毫秒 G1收集器之前的垃圾收集范围是整个新生代或老年代。G1收集器java内存布局分为多个大小相等的独立区域（Region）。但仍保留新生代和老年代的概念。建立可预测的停顿时间模型：跟踪各个Region里面垃圾堆积的价值大小，优先回收价值最大的Region。如何避免可达性分析中判定对象是否存活扫描整个java堆：Remembered Set:虚拟机对Reference数据写操作时，检查Reference引用的对象是否处于不同的Region，通过CardTable将相关引用信息记录到被引用对象所属Region的Remembered Set中。进行枚举根节点的时候，加入Remembered Set大致步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 理解GC日志 33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs] 100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] “33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。 “［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的；例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。 [Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] “［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。 后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。 而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。 “0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。 内存分配和回收策略 对象优先在Eden区分配 新生代 GC（Minor GC） 老年代 GC（Major GC/Full GC）对象优先在Eden区分配，空间不足，发生Minor GC 大对象直接进入老年代大量连续内存空间的java对象-很长的字符串，数组。 -XX:PretenureSizeThreshold参数（单位 kb）3. 长期存活对象将进入老年代阈值默认为15，-XX:MaxTenuringThreshold设置4. 动态对象年龄判断Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代5. 空间分配担保Minor GC之前–虚拟机检查老年代最大可用的连续空间是否大于新生代所有对象总空间 - 成立，那么Minor GC可以确保是安全的。 - 不成立，HandlePromotionFailure设置值是否允许担保失败–允许，续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， - 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的； - 如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 **注意：**JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略","link":"/2018/11/18/U3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"},{"title":"tomat源码解析-启动过程（一）","text":"bat简单语法关于bat的介绍和使用已经在前面给出，这里再介绍一下他的简单用法。 DOS命令 解释 rem 该命令用于注释，rem起始的行不会作为代码执行 pause 该命令用于暂停正在执行的批处理文件，并且提示用户按键，然后程序继续执行 echo 该命令用于在dos控制台显示一段文本，相当于print，如果想要显示环境变量需要在环境变量前后加上%，例如显示操作系统echo %OS% echo off 该命令可以防止将批处理文件中的具体命令打印出来，而只会输出执行结果 @echo off 该命令与echo off相同，唯一的区别在于@echo off不仅会隐藏具体命令还会连’echo off’这个自身命令也隐藏起来 set 设置环境变量，例如set A = 100设置A变量为100 label 使用’:’(冒号)来设置一个标签，供给goto命令使用，例如”：init”代表一个init标签 goto 该命令使正在执行的命令强制跳转到他指定的标签。例如我需要跳转指定A标签下的命令，如下：goto A not 该命令用来取反，相当于逻辑非 if 该命令表示判断 exist 该命令通常用来测试文件是否存在，一般和if一起使用 shift 该命令用来将参数后移一位即将%2%赋值给%1%，%3%赋值给%2%，也可以理解为参数列表左移即删除现有参数列表的第一位 call 该命令用来调用另外一条命令 setLocal 该命令表示该批处理文件中修改的环境变量只在本文件中起作用，或者直到endLocal命令出现，被修改的环境变量才恢复原状 start 重新开启一个dos窗口 startup.bat12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@echo offrem Licensed to the Apache Software Foundation (ASF) under one or morerem contributor license agreements. See the NOTICE file distributed withrem this work for additional information regarding copyright ownership.rem The ASF licenses this file to You under the Apache License, Version 2.0rem (the &quot;License&quot;); you may not use this file except in compliance withrem the License. You may obtain a copy of the License atremrem http://www.apache.org/licenses/LICENSE-2.0remrem Unless required by applicable law or agreed to in writing, softwarerem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.rem See the License for the specific language governing permissions andrem limitations under the License.rem ---------------------------------------------------------------------------rem Start script for the CATALINA Serverrem ---------------------------------------------------------------------------setlocalrem Guess CATALINA_HOME if not definedset &quot;CURRENT_DIR=%cd%&quot;if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHomeset &quot;CATALINA_HOME=%CURRENT_DIR%&quot;if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomecd ..set &quot;CATALINA_HOME=%cd%&quot;cd &quot;%CURRENT_DIR%&quot;:gotHomeif exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomeecho The CATALINA_HOME environment variable is not defined correctlyecho This environment variable is needed to run this programgoto end:okHomeset &quot;EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat&quot;rem Check that target executable existsif exist &quot;%EXECUTABLE%&quot; goto okExececho Cannot find &quot;%EXECUTABLE%&quot;echo This file is needed to run this programgoto end:okExecrem Get remaining unshifted command line arguments and save them in theset CMD_LINE_ARGS=:setArgsif &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgsset CMD_LINE_ARGS=%CMD_LINE_ARGS% %1shiftgoto setArgs:doneSetArgscall &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%:end @echo off，此语句常用于开头，表示不显示所有的命令行信息，包括此句。setlocal，启动批处理文件中环境变量的本地化，本地化将持续到出现匹配的endlocal命令或者到达批处理文件结尾为止。下面将文件拆成几段来看：第一段：判断CATALINA_HOME是否定义 rem Guess CATALINA_HOME if not defined set &quot;CURRENT_DIR=%cd%&quot; if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome set &quot;CATALINA_HOME=%CURRENT_DIR%&quot; if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHome cd .. set &quot;CATALINA_HOME=%cd%&quot; cd &quot;%CURRENT_DIR%&quot; 设置变量CURRENT_DIR为当前目录，一般打开的就是tomcat的bin目录，./apache-tomcat-x.x.xx/bin； 判断系统变量CATALINA_HOME是不是空串(一般安装tomcat时，我们都会配置CATALINA_HOME环境变量，不知有没有印象呢)，如果是就跳转到gotHome标签执行，假设CATALINA_HOME环境变量没有定义，就继续往下； 设置CATALINA_HOME为CURRENT_DIR指向的目录，也就是bin目录(./apache-tomcat-x.x.xx/bin)； 判断CATALINA_HOME\\bin\\catalina.bat文件是否存在，也就是 ./apache-tomcat-x.x.xx/bin/bin/catalina.bat，5 如果存在就转向okHome标签，显然是不存在的，所以不会跳转到okHome，继续往下； 不存在的话，CATALINA_HOME取上级目录的值，也就是(./apache-tomcat-x.x.xx/)； 设置CATALINA_HOME指向当前目录，也就是Tomcat的根目录； 进入 CURRENT_DIR(./apache-tomcat-x.x.xx/bin)； 第二段：执行gotHome标签 :gotHome if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHome echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end通过上面的设置，CATALINA_HOME的值已经是: ./apache-tomcat-x.x.xx/，这时判断./apache-tomcat-x.x.xx/catalina.bat 脚本是否存在，如果不存在，则输出一些信息结束，一般这时是可以找到的，所以跳转到okHome标签处；第三段：执行okHome标签 :okHome set &quot;EXECUTABLE=%CATALINA_HOME%\\bin\\catalina.bat&quot;设置EXECUTABLE变量指向为catalina.bat脚本； 第四段：再次检查catalina.bat是否存在 rem Check that target executable exists if exist &quot;%EXECUTABLE%&quot; goto okExec echo Cannot find &quot;%EXECUTABLE%&quot; echo This file is needed to run this program goto end双重保险继续判断下EXECUTABLE指向的catalina.bat文件是否存在，不存在就输出提示信息并且结束，存在就跳转到okExec标签处： 第五段： :okExec rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS= :setArgs if &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs call &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%set CMD_LINE_ARGS=表示清空变量CMD_LINE_ARGS；执行setArgs标签；第一个变量(%1%)为空字符串，那么就跳转到doneSetArgs标签，一般情况下，直接运行startup.bat，是没有传递任何参数，所以是跳转到doneSetArgs标签，由此也可以猜想出，如果不是使用双击执行的话，使用命令行启动startup.bat那么是可以传递参数的；跳转到doneSetArgs，调用EXECUTABLE指向的文件，也就是catalina.bat文件，同时传递start参数，因为CMD_LINE_ARGS为空，所以只传递了一个start参数；最后：end标签 :end判断失败跳转的标签，是参数不正确的时候的结束标志。 catalina.bat去掉前面的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244setlocalrem Suppress Terminate batch job on CTRL+Cif not &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto mainEntryif &quot;%TEMP%&quot; == &quot;&quot; goto mainEntryif exist &quot;%TEMP%\\%~nx0.run&quot; goto mainEntryecho Y&gt;&quot;%TEMP%\\%~nx0.run&quot;if not exist &quot;%TEMP%\\%~nx0.run&quot; goto mainEntryecho Y&gt;&quot;%TEMP%\\%~nx0.Y&quot;call &quot;%~f0&quot; %* &lt;&quot;%TEMP%\\%~nx0.Y&quot;rem Use provided errorlevelset RETVAL=%ERRORLEVEL%del /Q &quot;%TEMP%\\%~nx0.Y&quot; &gt;NUL 2&gt;&amp;1exit /B %RETVAL%:mainEntrydel /Q &quot;%TEMP%\\%~nx0.run&quot; &gt;NUL 2&gt;&amp;1rem Guess CATALINA_HOME if not definedset &quot;CURRENT_DIR=%cd%&quot;if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHomeset &quot;CATALINA_HOME=%CURRENT_DIR%&quot;if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomecd ..set &quot;CATALINA_HOME=%cd%&quot;cd &quot;%CURRENT_DIR%&quot;:gotHomeif exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomeecho The CATALINA_HOME environment variable is not defined correctlyecho This environment variable is needed to run this programgoto end:okHomerem Copy CATALINA_BASE from CATALINA_HOME if not definedif not &quot;%CATALINA_BASE%&quot; == &quot;&quot; goto gotBaseset &quot;CATALINA_BASE=%CATALINA_HOME%&quot;:gotBaserem Ensure that neither CATALINA_HOME nor CATALINA_BASE contains a semi-colonrem as this is used as the separator in the classpath and Java provides norem mechanism for escaping if the same character appears in the path. Check thisrem by replacing all occurrences of ';' with '' and checking that neitherrem CATALINA_HOME nor CATALINA_BASE have changedif &quot;%CATALINA_HOME%&quot; == &quot;%CATALINA_HOME:;=%&quot; goto homeNoSemicolonecho Using CATALINA_HOME: &quot;%CATALINA_HOME%&quot;echo Unable to start as CATALINA_HOME contains a semicolon (;) charactergoto end:homeNoSemicolonif &quot;%CATALINA_BASE%&quot; == &quot;%CATALINA_BASE:;=%&quot; goto baseNoSemicolonecho Using CATALINA_BASE: &quot;%CATALINA_BASE%&quot;echo Unable to start as CATALINA_BASE contains a semicolon (;) charactergoto end:baseNoSemicolonrem Ensure that any user defined CLASSPATH variables are not used on startup,rem but allow them to be specified in setenv.bat, in rare case when it is needed.set CLASSPATH=rem Get standard environment variablesif not exist &quot;%CATALINA_BASE%\\bin\\setenv.bat&quot; goto checkSetenvHomecall &quot;%CATALINA_BASE%\\bin\\setenv.bat&quot;goto setenvDone:checkSetenvHomeif exist &quot;%CATALINA_HOME%\\bin\\setenv.bat&quot; call &quot;%CATALINA_HOME%\\bin\\setenv.bat&quot;:setenvDonerem Get standard Java environment variablesif exist &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot; goto okSetclasspathecho Cannot find &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot;echo This file is needed to run this programgoto end:okSetclasspathcall &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot; %1if errorlevel 1 goto endrem Add on extra jar file to CLASSPATHrem Note that there are no quotes as we do not want to introduce randomrem quotes into the CLASSPATHif &quot;%CLASSPATH%&quot; == &quot;&quot; goto emptyClasspathset &quot;CLASSPATH=%CLASSPATH%;&quot;:emptyClasspathset &quot;CLASSPATH=%CLASSPATH%%CATALINA_HOME%\\bin\\bootstrap.jar&quot;if not &quot;%CATALINA_TMPDIR%&quot; == &quot;&quot; goto gotTmpdirset &quot;CATALINA_TMPDIR=%CATALINA_BASE%\\temp&quot;:gotTmpdirrem Add tomcat-juli.jar to classpathrem tomcat-juli.jar can be over-ridden per instanceif not exist &quot;%CATALINA_BASE%\\bin\\tomcat-juli.jar&quot; goto juliClasspathHomeset &quot;CLASSPATH=%CLASSPATH%;%CATALINA_BASE%\\bin\\tomcat-juli.jar&quot;goto juliClasspathDone:juliClasspathHomeset &quot;CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\\bin\\tomcat-juli.jar&quot;:juliClasspathDoneif not &quot;%JSSE_OPTS%&quot; == &quot;&quot; goto gotJsseOptsset JSSE_OPTS=&quot;-Djdk.tls.ephemeralDHKeySize=2048&quot;:gotJsseOptsset &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;if not &quot;%LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfigset LOGGING_CONFIG=-Dnopif not exist &quot;%CATALINA_BASE%\\conf\\logging.properties&quot; goto noJuliConfigset LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\\conf\\logging.properties&quot;:noJuliConfigset &quot;JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG%&quot;if not &quot;%LOGGING_MANAGER%&quot; == &quot;&quot; goto noJuliManagerset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager:noJuliManagerset &quot;JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER%&quot;rem ----- Execute The Requested Command ---------------------------------------echo Using CATALINA_BASE: &quot;%CATALINA_BASE%&quot;echo Using CATALINA_HOME: &quot;%CATALINA_HOME%&quot;echo Using CATALINA_TMPDIR: &quot;%CATALINA_TMPDIR%&quot;if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto use_jdkecho Using JRE_HOME: &quot;%JRE_HOME%&quot;goto java_dir_displayed:use_jdkecho Using JAVA_HOME: &quot;%JAVA_HOME%&quot;:java_dir_displayedecho Using CLASSPATH: &quot;%CLASSPATH%&quot;set _EXECJAVA=%_RUNJAVA%set MAINCLASS=org.apache.catalina.startup.Bootstrapset ACTION=startset SECURITY_POLICY_FILE=set DEBUG_OPTS=set JPDA=if not &quot;&quot;%1&quot;&quot; == &quot;&quot;jpda&quot;&quot; goto noJpdaset JPDA=jpdaif not &quot;%JPDA_TRANSPORT%&quot; == &quot;&quot; goto gotJpdaTransportset JPDA_TRANSPORT=dt_socket:gotJpdaTransportif not &quot;%JPDA_ADDRESS%&quot; == &quot;&quot; goto gotJpdaAddressset JPDA_ADDRESS=localhost:8000:gotJpdaAddressif not &quot;%JPDA_SUSPEND%&quot; == &quot;&quot; goto gotJpdaSuspendset JPDA_SUSPEND=n:gotJpdaSuspendif not &quot;%JPDA_OPTS%&quot; == &quot;&quot; goto gotJpdaOptsset JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%:gotJpdaOptsshift:noJpdaif &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto doDebugif &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto doRunif &quot;&quot;%1&quot;&quot; == &quot;&quot;start&quot;&quot; goto doStartif &quot;&quot;%1&quot;&quot; == &quot;&quot;stop&quot;&quot; goto doStopif &quot;&quot;%1&quot;&quot; == &quot;&quot;configtest&quot;&quot; goto doConfigTestif &quot;&quot;%1&quot;&quot; == &quot;&quot;version&quot;&quot; goto doVersionecho Usage: catalina ( commands ... )echo commands:echo debug Start Catalina in a debuggerecho debug -security Debug Catalina with a security managerecho jpda start Start Catalina under JPDA debuggerecho run Start Catalina in the current windowecho run -security Start in the current window with security managerecho start Start Catalina in a separate windowecho start -security Start in a separate window with security managerecho stop Stop Catalinaecho configtest Run a basic syntax check on server.xmlecho version What version of tomcat are you running?goto end:doDebugshiftset _EXECJAVA=%_RUNJDB%set DEBUG_OPTS=-sourcepath &quot;%CATALINA_HOME%\\..\\..\\java&quot;if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmdshiftecho Using Security Managerset &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot;goto execCmd:doRunshiftif not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmdshiftecho Using Security Managerset &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot;goto execCmd:doStartshiftif &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcatset _EXECJAVA=start &quot;%TITLE%&quot; %_RUNJAVA%if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmdshiftecho Using Security Managerset &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot;goto execCmd:doStopshiftset ACTION=stopset CATALINA_OPTS=goto execCmd:doConfigTestshiftset ACTION=configtestset CATALINA_OPTS=goto execCmd:doVersion%_EXECJAVA% -classpath &quot;%CATALINA_HOME%\\lib\\catalina.jar&quot; org.apache.catalina.util.ServerInfogoto end:execCmdrem Get remaining unshifted command line arguments and save them in theset CMD_LINE_ARGS=:setArgsif &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgsset CMD_LINE_ARGS=%CMD_LINE_ARGS% %1shiftgoto setArgs:doneSetArgsrem Execute Java with the applicable propertiesif not &quot;%JPDA%&quot; == &quot;&quot; goto doJpdaif not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurity%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%goto end:doSecurity%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%goto end:doJpdaif not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurityJpda%_EXECJAVA% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%goto end:doSecurityJpda%_EXECJAVA% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%goto end:end 第一段： rem Suppress Terminate batch job on CTRL+C if not &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto mainEntry if &quot;%TEMP%&quot; == &quot;&quot; goto mainEntry if exist &quot;%TEMP%\\%~nx0.run&quot; goto mainEntry echo Y&gt;&quot;%TEMP%\\%~nx0.run&quot; if not exist &quot;%TEMP%\\%~nx0.run&quot; goto mainEntry echo Y&gt;&quot;%TEMP%\\%~nx0.Y&quot; call &quot;%~f0&quot; %* &lt;&quot;%TEMP%\\%~nx0.Y&quot; rem Use provided errorlevel set RETVAL=%ERRORLEVEL% del /Q &quot;%TEMP%\\%~nx0.Y&quot; &gt;NUL 2&gt;&amp;1 exit /B %RETVAL% :mainEntry del /Q &quot;%TEMP%\\%~nx0.run&quot; &gt;NUL 2&gt;&amp;1 首先注释是说，禁止使用 CTRL+C 来终止批处理任务； if not “”%1”” == “”run”” goto mainEntry，第一个参数不是run，就转向mainEntry标签，通过调用startup.bat启动的第一个参数应该是start； if “%TEMP%” == “” goto mainEntry，%TEMP%是系统的环境变量值，通常装完windows系统的话, 系统会自动配置上这个环境变量，一般是C:\\Users\\用户名\\AppData\\Local\\Temp（AppData是一个隐藏文件夹）。这句是说，如果%TEMP%是空串，就转向mainEntry标签； if exist “%TEMP%%nx0.run” goto mainEntry， 在批处理中，%1 表示的是程序之后的第一个参数，%0表示这个可执行程序的名称， %nx0 的话就是程序的名称+扩展名，在这里就是catalina.bat（可以写一个脚本测试下）； echo Y&gt;”%TEMP%%~nx0.run”，写入字符Y到%TEMP%\\catalina.bat.run 文件中； if not exist “%TEMP%%~nx0.run” goto mainEntry，又判断了一下 %TEMP%\\catalina.bat.run 文件是否存在； echo Y&gt;”%TEMP%%~nx0.Y”，写入Y到%TEMP%\\catalina.bat.Y，如果文件不存在， 则新建一个； call “%f0” %* &lt;”%TEMP%%nx0.Y”，- “%f0” : 简单说就是表示当前命令的绝对路径。- “%” : %1表示第一个参数，%2表示第二个，%代表所有参数。&lt;”%TEMP%%nx0.Y”是读取 %TEMP%\\catalina.bat.Y文件中的内容，之后又通过call进行调用； set RETVAL=%ERRORLEVEL%，Windows中和linux一样，命令执行完之后都有自己的退出码，%ERRORLEVEL%就是取的上面的call 命令的退出码，赋值给一个变量RETVAL； del /Q “%TEMP%%~nx0.Y” &gt;NUL 2&gt;&amp;1，del 命令，很容易联想到delete， 那么/Q是什么意思呢?静默删除，不会给出任何提示，就比如Linux中的rm -f 一样。这里是删除%TEMP%\\catalina.bat.Y这个文件。后面的 &gt;NUL 2&gt;&amp;1又是什么意思呢? &gt;NUL : 表示将输出重定向到 NUL 中，你什么也看不到；2&gt;&amp;1 : 2:错误输出，&amp;1: 标准输出， 意思就是将错误消息输出到标准输出中；&gt;NUL 2&gt;&amp;1 : 就是先将错误消息输出到标准输出中，然后再输出到 NUL 中； exit /B %RETVAL%，退出当前批处理， /B 指定退出时的编号， 把 RETVAL 作为 退出码, 也就是 call 执行的命令的退出码； :mainEntry del /Q “%TEMP%%~nx0.run” &gt;NUL 2&gt;&amp;1，定义一个 mainEntry 标签，然后删除临时目录中的 catalina.bat.run 文件。 这段代码的作用就是调用本身，判断临时目录中的文件是否存在来避免二次回调自己。感觉绕的很晕，迷迷糊糊的，不知道设计者的意图。有没有大神可以帮忙解惑？ Tips： %~nx0表示这个程序的名称+扩展名（catalina.bat) %~f0表示当前命令的绝对路径 “&lt;” 表示读取文件内容 &gt;NUL 输出重定向到NUL中 2&gt;&amp;1 将错误信息输出到标准输出中 第二段： rem Guess CATALINA_HOME if not defined set &quot;CURRENT_DIR=%cd%&quot; if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome set &quot;CATALINA_HOME=%CURRENT_DIR%&quot; if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHome cd .. set &quot;CATALINA_HOME=%cd%&quot; cd &quot;%CURRENT_DIR%&quot; :gotHome if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHome echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end :okHome rem Copy CATALINA_BASE from CATALINA_HOME if not defined if not &quot;%CATALINA_BASE%&quot; == &quot;&quot; goto gotBase set &quot;CATALINA_BASE=%CATALINA_HOME%&quot; :gotBase set “CURRENT_DIR=%cd%”，设置CURRENT_DIR为当前目录bin(假如你是在bin目录中启动）； if not “%CATALINA_HOME%” == “” goto gotHome，CATALINA_HOME不是空就转向gotHome； set “CATALINA_HOME=%CURRENT_DIR%”，设置CATALINA_HOME指向CURRENT_DIR的目录，也就是bin目录； if exist “%CATALINA_HOME%\\bin\\catalina.bat” goto okHome，如果存在%CATALINA_HOME%\\bin\\catalina.bat，那么就转向okHome，否则退出到父目录，(显然不存在bin\\bin\\catalina.bat)； set “CATALINA_HOME=%cd%”，设置CATALINA_HOME为当前目录(也就是Tomcat的根目录）； cd “%CURRENT_DIR%”，进入CURRENT_HOME指向的目录，也就是bin目录，执行gotHome标签； if exist “%CATALINA_HOME%\\bin\\catalina.bat” goto okHome，gotHome标签下，如果存在%CATALINA_HOME%\\bin\\catalina.bat，就转向okHome，因为CATALINA_HOME现在指向的目录是Tomcat的安装目录，所以\\bin\\catalina.bat文件是存在的，所以转向okHome标签； if not “%CATALINA_BASE%” == “” goto gotBase，如果CATALINA_BASE变量不是空，就转向gotBase标签(显然为空)； set “CATALINA_BASE=%CATALINA_HOME%”，设置CATALINA_BASE的值等同与CATALINA_HOME的值(现在CATALINA_BASE也指向的Tomcat的根目录了)。 这段主要是设置了两个环境变量 CATALINA_HOME 和 CATALINA_BASE。如果没有配置 CATALINA_BASE 环境变量的话, 直接引用 CATALINA_HOME 的值。 第三段： rem Ensure that neither CATALINA_HOME nor CATALINA_BASE contains a semi-colon rem as this is used as the separator in the classpath and Java provides no rem mechanism for escaping if the same character appears in the path. Check this rem by replacing all occurrences of &apos;;&apos; with &apos;&apos; and checking that neither rem CATALINA_HOME nor CATALINA_BASE have changed if &quot;%CATALINA_HOME%&quot; == &quot;%CATALINA_HOME:;=%&quot; goto homeNoSemicolon echo Using CATALINA_HOME: &quot;%CATALINA_HOME%&quot; echo Unable to start as CATALINA_HOME contains a semicolon (;) character goto end :homeNoSemicolon if &quot;%CATALINA_BASE%&quot; == &quot;%CATALINA_BASE:;=%&quot; goto baseNoSemicolon echo Using CATALINA_BASE: &quot;%CATALINA_BASE%&quot; echo Unable to start as CATALINA_BASE contains a semicolon (;) character goto end :baseNoSemicolon这里主要是判断 CATALINA_HOME 环境变量的值 和 CATALINA_BASE 环境变量的值是否以分号为结尾，如果以分号为结尾的话，就报错退出。 第四段： rem Ensure that any user defined CLASSPATH variables are not used on startup, rem but allow them to be specified in setenv.bat, in rare case when it is needed. set CLASSPATH= rem Get standard environment variables if not exist &quot;%CATALINA_BASE%\\bin\\setenv.bat&quot; goto checkSetenvHome call &quot;%CATALINA_BASE%\\bin\\setenv.bat&quot; goto setenvDone :checkSetenvHome if exist &quot;%CATALINA_HOME%\\bin\\setenv.bat&quot; call &quot;%CATALINA_HOME%\\bin\\setenv.bat&quot; :setenvDone rem Get standard Java environment variables if exist &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot; goto okSetclasspath echo Cannot find &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot; echo This file is needed to run this program goto end :okSetclasspath call &quot;%CATALINA_HOME%\\bin\\setclasspath.bat&quot; %1 if errorlevel 1 goto end主要是说，如果Tomcat的bin目录下面存在setenv.bat脚本的话(setenv.bat是干什么的？上面的注释说是用户自定义的环境变量，但并不是启动时必须的定义在setenv.bat中)，就执行它，通常情况下是没有的，继而又判断setclasspath.bat脚本是否存在，如果不存在的话， 直接报错，停止启动 Tomcat。如果存在的话，就去调用它，并把 第一个参数传进去。 可以进入setclasspath.bat脚本看下，主要设置了以下几个环境变量： JAVA_HOME JRE_HOME JAVA_ENDORSED_DIRS = %CATALINA_HOME%\\endorsed _RUNJAVA = %JRE_HOME%\\bin\\java.exe _RUNJDB = %JAVA_HOME%\\bin\\jdb.exe所以这段是设置临时环境变量: CLASSPATH和setclasspath 第五段： rem Add on extra jar file to CLASSPATH rem Note that there are no quotes as we do not want to introduce random rem quotes into the CLASSPATH if &quot;%CLASSPATH%&quot; == &quot;&quot; goto emptyClasspath set &quot;CLASSPATH=%CLASSPATH%;&quot; :emptyClasspath set &quot;CLASSPATH=%CLASSPATH%%CATALINA_HOME%\\bin\\bootstrap.jar&quot; if not &quot;%CATALINA_TMPDIR%&quot; == &quot;&quot; goto gotTmpdir set &quot;CATALINA_TMPDIR=%CATALINA_BASE%\\temp&quot; :gotTmpdir rem Add tomcat-juli.jar to classpath rem tomcat-juli.jar can be over-ridden per instance if not exist &quot;%CATALINA_BASE%\\bin\\tomcat-juli.jar&quot; goto juliClasspathHome set &quot;CLASSPATH=%CLASSPATH%;%CATALINA_BASE%\\bin\\tomcat-juli.jar&quot; goto juliClasspathDone :juliClasspathHome set &quot;CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\\bin\\tomcat-juli.jar&quot; :juliClasspathDone这段代码主要做了三件事: 把 Tomcat bin 目录下的 bootstrap.jar 加入到环境变量中； 设置 CATALINA_TMPDIR 环境变量的值为 Tomcat 目录下的 temp 目录； 把 Tomcat bin 目录下的 tomcat-juli.jar 加入到环境变量中； 第六段： if not &quot;%JSSE_OPTS%&quot; == &quot;&quot; goto gotJsseOpts set JSSE_OPTS=&quot;-Djdk.tls.ephemeralDHKeySize=2048&quot; :gotJsseOpts set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot; rem Register custom URL handlers rem Do this here so custom URL handles (specifically &apos;war:...&apos;) can be used in the security policy set &quot;JAVA_OPTS=%JAVA_OPTS% -Djava.protocol.handler.pkgs=org.apache.catalina.webresources&quot; if not &quot;%LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfig set LOGGING_CONFIG=-Dnop if not exist &quot;%CATALINA_BASE%\\conf\\logging.properties&quot; goto noJuliConfig set LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\\conf\\logging.properties&quot; :noJuliConfig if not &quot;%LOGGING_MANAGER%&quot; == &quot;&quot; goto noJuliManager set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager :noJuliManager rem Configure JAVA 9 specific start-up parameters set &quot;JDK_JAVA_OPTIONS=%JDK_JAVA_OPTIONS% --add-opens=java.base/java.lang=ALL-UNNAMED&quot; set &quot;JDK_JAVA_OPTIONS=%JDK_JAVA_OPTIONS% --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED&quot;主要是追加一系列的启动参数到 JAVA_OPTS 这个环境变量中。 第七段： echo Using CATALINA_BASE: &quot;%CATALINA_BASE%&quot; echo Using CATALINA_HOME: &quot;%CATALINA_HOME%&quot; echo Using CATALINA_TMPDIR: &quot;%CATALINA_TMPDIR%&quot; if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto use_jdk echo Using JRE_HOME: &quot;%JRE_HOME%&quot; goto java_dir_displayed :use_jdk echo Using JAVA_HOME: &quot;%JAVA_HOME%&quot; :java_dir_displayed echo Using CLASSPATH: &quot;%CLASSPATH%&quot;打印相关的环境变量信息。 第八段： set _EXECJAVA=%_RUNJAVA% set MAINCLASS=org.apache.catalina.startup.Bootstrap set ACTION=start set SECURITY_POLICY_FILE= set DEBUG_OPTS= set JPDA=设置一些环境变量: _RUNJAVA : %JRE_HOME%\\bin\\java.exe； MAINCLASS : 指定了 Tomcat 的启动类； ACTION : 动作， 就是启动； SECURITY_POLICY_FILE : 安全策略文件，如果启动的时候加上了 -security 参数的话，下面会对这个参数指定到 Tomcat 的 conf 目录下的 catalina.policy 文件； JPDA : 还不清楚，猜测是数据库相关技术，目前暂时忽略 。 第九段： if not &quot;&quot;%1&quot;&quot; == &quot;&quot;jpda&quot;&quot; goto noJpda set JPDA=jpda if not &quot;%JPDA_TRANSPORT%&quot; == &quot;&quot; goto gotJpdaTransport set JPDA_TRANSPORT=dt_socket :gotJpdaTransport if not &quot;%JPDA_ADDRESS%&quot; == &quot;&quot; goto gotJpdaAddress set JPDA_ADDRESS=localhost:8000 :gotJpdaAddress if not &quot;%JPDA_SUSPEND%&quot; == &quot;&quot; goto gotJpdaSuspend set JPDA_SUSPEND=n :gotJpdaSuspend if not &quot;%JPDA_OPTS%&quot; == &quot;&quot; goto gotJpdaOpts set JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND% :gotJpdaOpts shift :noJpda第十段： if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto doDebug if &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto doRun if &quot;&quot;%1&quot;&quot; == &quot;&quot;start&quot;&quot; goto doStart if &quot;&quot;%1&quot;&quot; == &quot;&quot;stop&quot;&quot; goto doStop if &quot;&quot;%1&quot;&quot; == &quot;&quot;configtest&quot;&quot; goto doConfigTest if &quot;&quot;%1&quot;&quot; == &quot;&quot;version&quot;&quot; goto doVersion echo Usage: catalina ( commands ... ) echo commands: echo debug Start Catalina in a debugger echo debug -security Debug Catalina with a security manager echo jpda start Start Catalina under JPDA debugger echo run Start Catalina in the current window echo run -security Start in the current window with security manager echo start Start Catalina in a separate window echo start -security Start in a separate window with security manager echo stop Stop Catalina echo configtest Run a basic syntax check on server.xml echo version What version of tomcat are you running? goto end如果用 startup.bat 启动 Tomcat 的话， 这里的 “%1” 的值是 start；如果通过 catalina.bat run 启动 Tomcat 的话，这里的 “%1” 的值是 run； 第十一段： :doDebug shift set _EXECJAVA=%_RUNJDB% set DEBUG_OPTS=-sourcepath &quot;%CATALINA_HOME%\\..\\..\\java&quot; if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd shift echo Using Security Manager set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot; goto execCmd :doRun shift if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd shift echo Using Security Manager set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot; goto execCmd :doStart shift if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat set _EXECJAVA=start &quot;%TITLE%&quot; %_RUNJAVA% if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd shift echo Using Security Manager set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\\conf\\catalina.policy&quot; goto execCmd :doStop shift set ACTION=stop set CATALINA_OPTS= goto execCmd :doConfigTest shift set ACTION=configtest set CATALINA_OPTS= goto execCmd :doVersion %_EXECJAVA% -classpath &quot;%CATALINA_HOME%\\lib\\catalina.jar&quot; org.apache.catalina.util.ServerInfo goto end分别对应前面的标签，启动主要涉及doRun和doStart。 第一个 shift 是把 start 或者 run 参数移除，然后下面 还是利用 “%1” 来取参数， 这时候， 取出来的就是参数列表中的第二个；第二个 shift 是把第二个参数移除掉。 我们再来比较一下 start 和 run 的启动区别. 如果是 startup.bat 脚本启动的话， 会启动一个新的 cmd 窗口， 并且把 cmd 的 title 设置为 Tomcat。如果是 catalina.bat run 启动的话， 不会新建 cmd 窗口, 也不会设置 cmd 的 title。 最后都跳到了 execCmd 标签处。 第十二段： :execCmd rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS= :setArgs if &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs这里还是利用 “%1” 来取出启动命令之后的参数， 如果存在， 追加到 CMD_LINE_ARGS 环境变量上，并把这个参数移除。通常情况下，这里是不会有什么参数。 第十三段： rem Execute Java with the applicable properties if not &quot;%JPDA%&quot; == &quot;&quot; goto doJpda if not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurity %_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doSecurity %_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doJpda if not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurityJpda %_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doSecurityJpda %_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :end正常启动，不会有jdpa，也不会有security，所以这大段代码主要是加一些环境变量，然后带上参数去启动org.apache.catalina.startup.Bootstrap的main方法。 五、总结启动tomcat可以双击startup.bat，也可以在命令行直接catalina.bat run，大致的流程是这样： 首先判断一下用户直接使用 catalina.bat run 来启动 Tocmat； 设置 CATALINA_HOME 和 CATALINA_BASE 环境变量值； 验证 CATALINA_HOME 和 CATALINA_BASE 环境变量值的正确性； 调用 setnv.bat 脚本； 调用 setclasspath.bat 脚本； 添加 bootstrap.jar 和 tomcat-juli.jar 到 CLASSPATH 中； 设置 CATALINA_TMPDIR 临时目录的值为 Tomcat 目录下的 temp； 追加一系列的参数到 JAVA_OPTS 中； 整合相关的启动信息，参数； 启动 Tomcat。 参考链接：https://blog.csdn.net/w1992wishes/article/details/79317817","link":"/2018/10/29/tomat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"servletmapping中&#x2F;和&#x2F;*的区别--打破砂锅问到底系列","text":"前言在JavaWeb的学习中，我们都知道，在配置dispatchServletMapping的时候，需要配置的路径/,而不是/*。/*会拦截所有请求，包括jsp请求。为什么呢？这个时候一般会探究到web.xml文件的配置，其中defaultServlet的url是/,是web容器（这里特指tomcat）默认的请求处理器，我们自己配置/覆盖了这个默认的请求处理器，这个时候就会调用我们的dispatcherServlet（即一般的springmvc的时候）。还有一个jsp相关的servlet配置，处理的是jsp请求，即*.jsp。我们没有覆盖这个servlet，所以jsp请求还是由web容器自己处理。 123456789101112&lt;!-- The mapping for the default servlet --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 解释一般到这里就戛然而止了，不过依然没有解决我们的问题，/和/*都是匹配所有路径，那为什么/就不会覆盖了呢？ 砂锅本着这个问题，网上搜了好一阵，终于找到一篇解释正确的博文: servlet的url-pattern匹配规则.主要讲serlet的四中匹配方式和顺序：精确匹配》路径匹配》扩展名匹配》缺省匹配。而/*属于路径匹配，当我们这样写的时候，它的顺序在jsp的扩展名匹配（如上面代码所示，*.jsp,*.jspx）前面的，所以会覆盖。而/属于缺省匹配，顺序在jsp扩展名匹配后面，所以不会覆盖。 底继续这个问题，话是这么说，但是还是不放心怎么办？怎么证明你说的是对的？想直接从源码找到答案，奈何鄙人实力有限没找到。于是又费劲找了一篇博文，里面从源码层面印证了这个问题。Tomcat Url 映射源码学习文章有点长，不想看的话可以直接看结论： 一是tomcat在初始化的时候对不同url放入了不同的wrapper中了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 // 调用该addMapping的方法在StandardContext的addServletMapping方法内 // fireContainerEvent(&quot;addServletMapping&quot;, decodedPattern); } else if (Wrapper.ADD_MAPPING_EVENT.equals(event.getType())) { // Handle dynamically adding wrappers Wrapper wrapper = (Wrapper) event.getSource(); Context context = (Context) wrapper.getParent(); String contextPath = context.getPath(); if (&quot;/&quot;.equals(contextPath)) { contextPath = &quot;&quot;; } String version = context.getWebappVersion(); String hostName = context.getParent().getName(); String wrapperName = wrapper.getName(); String mapping = (String) event.getData(); boolean jspWildCard = (&quot;jsp&quot;.equals(wrapperName) &amp;&amp; mapping.endsWith(&quot;/*&quot;)); mapper.addWrapper(hostName, contextPath, version, mapping, wrapper, jspWildCard, context.isResourceOnlyServlet(wrapperName));// mapper的addwrapper方法protected void addWrapper(ContextVersion context, String path, Wrapper wrapper, boolean jspWildCard, boolean resourceOnly) { synchronized (context) { if (path.endsWith(&quot;/*&quot;)) { // Wildcard wrapper String name = path.substring(0, path.length() - 2); MappedWrapper newWrapper = new MappedWrapper(name, wrapper, jspWildCard, resourceOnly); MappedWrapper[] oldWrappers = context.wildcardWrappers; MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length + 1]; if (insertMap(oldWrappers, newWrappers, newWrapper)) { context.wildcardWrappers = newWrappers; int slashCount = slashCount(newWrapper.name); if (slashCount &gt; context.nesting) { context.nesting = slashCount; } } } else if (path.startsWith(&quot;*.&quot;)) { // Extension wrapper String name = path.substring(2); MappedWrapper newWrapper = new MappedWrapper(name, wrapper, jspWildCard, resourceOnly); MappedWrapper[] oldWrappers = context.extensionWrappers; MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length + 1]; if (insertMap(oldWrappers, newWrappers, newWrapper)) { context.extensionWrappers = newWrappers; } } else if (path.equals(&quot;/&quot;)) { // Default wrapper MappedWrapper newWrapper = new MappedWrapper(&quot;&quot;, wrapper, jspWildCard, resourceOnly); context.defaultWrapper = newWrapper; } else { // Exact wrapper final String name; if (path.length() == 0) { // Special case for the Context Root mapping which is // treated as an exact match name = &quot;/&quot;; } else { name = path; } MappedWrapper newWrapper = new MappedWrapper(name, wrapper, jspWildCard, resourceOnly); MappedWrapper[] oldWrappers = context.exactWrappers; MappedWrapper[] newWrappers = new MappedWrapper[oldWrappers.length + 1]; if (insertMap(oldWrappers, newWrappers, newWrapper)) { context.exactWrappers = newWrappers; } } }} /* 放在wildcardWrappers中 *. 放在extensionWrappers中 / 放在defaultWrapper中 其他 放在exactWrappers中 二是新来的http请求，需要找到合适的engine、host、context、wrapper进行处理，在接收到新的请求之后，在CoyoteAdapt类中调用map方法,再调用internalMap方法，这个方法中可以为mappingdata设置整个链路的容器（除了wrapper），最后的internalMapWrapper 明确最后的wrapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197………………………………// 根据URL匹配具体的wrapper规则private final void internalMapWrapper(ContextVersion contextVersion, CharChunk path, MappingData mappingData) throws IOException { int pathOffset = path.getOffset(); int pathEnd = path.getEnd(); boolean noServletPath = false; int length = contextVersion.path.length(); if (length == (pathEnd - pathOffset)) { noServletPath = true; } int servletPath = pathOffset + length; path.setOffset(servletPath); // Rule 1 -- Exact Match MappedWrapper[] exactWrappers = contextVersion.exactWrappers; internalMapExactWrapper(exactWrappers, path, mappingData); // Rule 2 -- Prefix Match boolean checkJspWelcomeFiles = false; MappedWrapper[] wildcardWrappers = contextVersion.wildcardWrappers; if (mappingData.wrapper == null) { internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting, path, mappingData); if (mappingData.wrapper != null &amp;&amp; mappingData.jspWildCard) { char[] buf = path.getBuffer(); if (buf[pathEnd - 1] == '/') { /* * Path ending in '/' was mapped to JSP servlet based on * wildcard match (e.g., as specified in url-pattern of a * jsp-property-group. * Force the context's welcome files, which are interpreted * as JSP files (since they match the url-pattern), to be * considered. See Bugzilla 27664. */ mappingData.wrapper = null; checkJspWelcomeFiles = true; } else { // See Bugzilla 27704 mappingData.wrapperPath.setChars(buf, path.getStart(), path.getLength()); mappingData.pathInfo.recycle(); } } } if(mappingData.wrapper == null &amp;&amp; noServletPath &amp;&amp; contextVersion.object.getMapperContextRootRedirectEnabled()) { // The path is empty, redirect to &quot;/&quot; path.append('/'); pathEnd = path.getEnd(); mappingData.redirectPath.setChars (path.getBuffer(), pathOffset, pathEnd - pathOffset); path.setEnd(pathEnd - 1); return; } // Rule 3 -- Extension Match MappedWrapper[] extensionWrappers = contextVersion.extensionWrappers; if (mappingData.wrapper == null &amp;&amp; !checkJspWelcomeFiles) { internalMapExtensionWrapper(extensionWrappers, path, mappingData, true); } // Rule 4 -- Welcome resources processing for servlets if (mappingData.wrapper == null) { boolean checkWelcomeFiles = checkJspWelcomeFiles; if (!checkWelcomeFiles) { char[] buf = path.getBuffer(); checkWelcomeFiles = (buf[pathEnd - 1] == '/'); } if (checkWelcomeFiles) { for (int i = 0; (i &lt; contextVersion.welcomeResources.length) &amp;&amp; (mappingData.wrapper == null); i++) { path.setOffset(pathOffset); path.setEnd(pathEnd); path.append(contextVersion.welcomeResources[i], 0, contextVersion.welcomeResources[i].length()); path.setOffset(servletPath); // Rule 4a -- Welcome resources processing for exact macth internalMapExactWrapper(exactWrappers, path, mappingData); // Rule 4b -- Welcome resources processing for prefix match if (mappingData.wrapper == null) { internalMapWildcardWrapper (wildcardWrappers, contextVersion.nesting, path, mappingData); } // Rule 4c -- Welcome resources processing // for physical folder if (mappingData.wrapper == null &amp;&amp; contextVersion.resources != null) { String pathStr = path.toString(); WebResource file = contextVersion.resources.getResource(pathStr); if (file != null &amp;&amp; file.isFile()) { internalMapExtensionWrapper(extensionWrappers, path, mappingData, true); if (mappingData.wrapper == null &amp;&amp; contextVersion.defaultWrapper != null) { mappingData.wrapper = contextVersion.defaultWrapper.object; mappingData.requestPath.setChars (path.getBuffer(), path.getStart(), path.getLength()); mappingData.wrapperPath.setChars (path.getBuffer(), path.getStart(), path.getLength()); mappingData.requestPath.setString(pathStr); mappingData.wrapperPath.setString(pathStr); } } } } path.setOffset(servletPath); path.setEnd(pathEnd); } } /* welcome file processing - take 2 * Now that we have looked for welcome files with a physical * backing, now look for an extension mapping listed * but may not have a physical backing to it. This is for * the case of index.jsf, index.do, etc. * A watered down version of rule 4 */ if (mappingData.wrapper == null) { boolean checkWelcomeFiles = checkJspWelcomeFiles; if (!checkWelcomeFiles) { char[] buf = path.getBuffer(); checkWelcomeFiles = (buf[pathEnd - 1] == '/'); } if (checkWelcomeFiles) { for (int i = 0; (i &lt; contextVersion.welcomeResources.length) &amp;&amp; (mappingData.wrapper == null); i++) { path.setOffset(pathOffset); path.setEnd(pathEnd); path.append(contextVersion.welcomeResources[i], 0, contextVersion.welcomeResources[i].length()); path.setOffset(servletPath); internalMapExtensionWrapper(extensionWrappers, path, mappingData, false); } path.setOffset(servletPath); path.setEnd(pathEnd); } } // Rule 7 -- Default servlet if (mappingData.wrapper == null &amp;&amp; !checkJspWelcomeFiles) { if (contextVersion.defaultWrapper != null) { mappingData.wrapper = contextVersion.defaultWrapper.object; mappingData.requestPath.setChars (path.getBuffer(), path.getStart(), path.getLength()); mappingData.wrapperPath.setChars (path.getBuffer(), path.getStart(), path.getLength()); mappingData.matchType = MappingMatch.DEFAULT; } // Redirection to a folder char[] buf = path.getBuffer(); if (contextVersion.resources != null &amp;&amp; buf[pathEnd -1 ] != '/') { String pathStr = path.toString(); WebResource file; // Handle context root if (pathStr.length() == 0) { file = contextVersion.resources.getResource(&quot;/&quot;); } else { file = contextVersion.resources.getResource(pathStr); } if (file != null &amp;&amp; file.isDirectory() &amp;&amp; contextVersion.object.getMapperDirectoryRedirectEnabled()) { // Note: this mutates the path: do not do any processing // after this (since we set the redirectPath, there // shouldn't be any) path.setOffset(pathOffset); path.append('/'); mappingData.redirectPath.setChars (path.getBuffer(), path.getStart(), path.getLength()); } else { mappingData.requestPath.setString(pathStr); mappingData.wrapperPath.setString(pathStr); } } } path.setOffset(pathOffset); path.setEnd(pathEnd);} 其它其实这个问题萦绕心间好久了，现在也有点过时了。不过以前一直没有解决，今天终于能完全弄明白，心里还是很愉快的，说明自己还是有一点进步的。","link":"/2020/06/16/servletmapping%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB-%E6%89%93%E7%A0%B4%E7%A0%82%E9%94%85%E9%97%AE%E5%88%B0%E5%BA%95%E7%B3%BB%E5%88%97/"},{"title":"Mybatis 数据库连接池&#x2F;数据源的思考库","text":"在学习Springboot项目的过程中，看到使用Mybatis的时候有些配置了数据源，有些没有配置，数据源的类型又有很多，产生了困惑，因此思考和查阅了一些资料，这里做一下总结。 概念JDBC JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。 JDBC编程步骤： 加载驱动 获取连接 创建Statement\\PreparedStatement对象 执行数据操作 关闭连接 数据源 数据源是指数据库应用程序所使用的数据库或者数据库服务器。数据源（Data Source）顾名思义，数据的来源，是提供某种所需要数据的器件或原始媒体。在数据源中存储了所有建立数据库连接的信息。就像通过指定文件名称可以在文件系统中找到文件一样，通过提供正确的数据源名称，你可以找到相应的数据库连接。 数据库连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。 区别和联系 连接池：连接池是用来管理池中的连接对象。连接池自动分配连接对象并对闲置的连接进行回收。连接池中的连接对象是由数据源（DataSource）创建的。连接池（Connection Pool）用来管理连接（Connection）对象。 数据源：数据源（DataSource）用来连接数据库，创建连接（Connection）对象。java.sql.DataSource接口负责建立与数据库的连接 数据源所谓数据源也就是数据的来源。它存储了所有建立数据库连接需要的信息。算是对数据库的一个抽象映射，即一个数据源对于一个数据库。 数据源有以下属性 databaseName String数据库名称，即数据库的SID。 dataSourceName String数据源接口实现类的名称。 description String 对数据源的描述。 networkProtocol String 和服务器通讯使用的网络协议名。 password String 用户登录密码。 portNumber数据库服务器使用的端口。 serverName String数据库服务器名称。 user String 用户登录名。 如果数据是水，数据库就是水库，数据源就是连接水库的管道，终端用户看到的数据集是管道里流出来的水。 数据源的作用是获取数据库连接，连接池是对已近创建好的数据库连接对象进行管理。 连接池里放的是数据库连接对象，数据源是要去获取一个数据库连接，也可以说是去获取一个数据库连接对象，对象代表的就是一个连接嘛。数据源是一个源头、一个路径、一个获取连接的过程。 连接池里放的就是一个一个的连接对象。调用数据源就可以去获得一个连接。 常用的数据库连接池DBCP,C3P0,Druid 1）DBCP DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。 ** 2）c3p0** c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 3）Druid 阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个 SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。Druid针对Oracle和MySql做了特别优化，比如Oracle的PS Cache内存占用优化，MySql的ping检测优化。Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。简单SQL语句用时10微秒以内，复杂SQL用时30微秒。通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析语义实现的。 参考链接：https://www.cnblogs.com/lannoy/p/5824866.html Mybatis中使用数据源的方式默认的，Mybatis使用自己的数据源。 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_0325&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; MyBatis中数据源可以分为三类，UNPOOLED、POOLED和JNDI类。使用UnpooledDataSource，PooledDataSource来分别表示前两种数据源，两者都实现了javax.sql.DataSource接口；而JNDI类的数据源则是则是通过JNDI上下文中取值。参考链接：## Mybatis 数据源和数据库连接池源码解析这里是一段摘录：（PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池， UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接） 而Mybatis也可以配置外部的数据库连接池。在Spring boot中，简化了配置过程。只需要引入依赖和配置相应数据源即可。在ssm开发中，配置xml时还需要将数据源整合进Mybatis。这一点在整合多数据源的时候能体现出来，需要将不同的数据源整合进不同的sqlSessionFactory中。 SSM中相关配置 123456789101112131415161718&lt;!--1、配数据源 --&gt; &lt;bean id=&quot;ds&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${jdbc.maxPoolSize}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${jdbc.minPoolSize}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 可以根据配置文件得到sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 指定配置文件位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt; &lt;!-- 指定xml映射文件的位置 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mybatis/mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Spring boot相关 123456789101112131415//pom中配置&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 配置数据源 123456789101112131415@Configurationpublic class DataSourceConfig { @Autowired private Environment env; @Bean public DataSource getDataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty(&quot;spring.datasource.url&quot;)); dataSource.setUsername(env.getProperty(&quot;spring.datasource.username&quot;)); dataSource.setPassword(env.getProperty(&quot;spring.datasource.password&quot;)); return dataSource; }} 参考链接：https://blog.csdn.net/pengjunlee/article/details/80081231 下面是两篇配置多数据源的参考文档，没有试验过，私认为第一篇比较好。Spring Boot + Mybatis多数据源和动态数据源配置SpringBoot/Mybatis/Druid, 多数据源MultiDataSource配置思路","link":"/2020/06/16/Mybatis-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E6%80%9D%E8%80%83%E5%BA%93/"},{"title":"tomat源码解析-启动过程（二）","text":"main方法上一篇中介绍了startup.bat和catalina.bat脚本。了解到日常双击startup.bat启动tomcat，其实是来到catalina.bat脚本中，由catalina.bat脚本去执行org.apache.catalina.startup.Bootstrap这个类中的main方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String args[]) { if (daemon == null) { // Don't set daemon until init() has completed Bootstrap bootstrap = new Bootstrap(); try { bootstrap.init(); } catch (Throwable t) { handleThrowable(t); t.printStackTrace(); return; } daemon = bootstrap; } else { // When running as a service the call to stop will be on a new // thread so make sure the correct class loader is used to prevent // a range of class not found exceptions. Thread.currentThread().setContextClassLoader(daemon.catalinaLoader); } try { String command = &quot;start&quot;; if (args.length &gt; 0) { command = args[args.length - 1]; } if (command.equals(&quot;startd&quot;)) { args[args.length - 1] = &quot;start&quot;; daemon.load(args); daemon.start(); } else if (command.equals(&quot;stopd&quot;)) { args[args.length - 1] = &quot;stop&quot;; daemon.stop(); } else if (command.equals(&quot;start&quot;)) { daemon.setAwait(true); daemon.load(args); daemon.start(); } else if (command.equals(&quot;stop&quot;)) { daemon.stopServer(args); } else if (command.equals(&quot;configtest&quot;)) { daemon.load(args); if (null==daemon.getServer()) { System.exit(1); } System.exit(0); } else { log.warn(&quot;Bootstrap: command \\&quot;&quot; + command + &quot;\\&quot; does not exist.&quot;); } } catch (Throwable t) { // Unwrap the Exception for clearer error reporting if (t instanceof InvocationTargetException &amp;&amp; t.getCause() != null) { t = t.getCause(); } handleThrowable(t); t.printStackTrace(); System.exit(1); } } 可以看出main方法大致可以分为两部分。 上部分是实例化一个Bootstrap对象，并调用init方法，然后赋值给daemon变量（是一个BootStrap类型对象），当然如果daemon已经不是空了，说明已经初始化过了，就将daemon.catalinaLoader直接设置到当前线程（daemon.catalinaLoader是用来加载tomcat内部服务器所需类的类加载器）。 下部分是根据传递进来的参数决定走哪一步，当双击startup.bat时，传进来的是start，所以会来到这段： else if (command.equals(&quot;start&quot;)) { daemon.setAwait(true); daemon.load(args); daemon.start(); }这里主要是调用三个方法，setAwait，load和start。 所以对于Bootstrap重要关注的就是init，setAwait，load和start这四个方法。 init方法public void init() throws Exception { initClassLoaders(); Thread.currentThread().setContextClassLoader(catalinaLoader); SecurityClassLoad.securityClassLoad(catalinaLoader); // Load our startup class and call its process() method if (log.isDebugEnabled()) log.debug(&quot;Loading startup class&quot;); Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); Object startupInstance = startupClass.getConstructor().newInstance(); // Set the shared extensions class loader if (log.isDebugEnabled()) log.debug(&quot;Setting startup class properties&quot;); String methodName = &quot;setParentClassLoader&quot;; Class&lt;?&gt; paramTypes[] = new Class[1]; paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;); Object paramValues[] = new Object[1]; paramValues[0] = sharedLoader; Method method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues); catalinaDaemon = startupInstance; }init方法调用initClassLoaders初始化类加载器，然后将初始化好的catalinaLoader设置到当前线程，接着通过反射调用org.apache.catalina.startup.Catalina类的setParentClassLoader，将sharedLoader传入。 1. initClassLoaders方法private void initClassLoaders() { try { commonLoader = createClassLoader(&quot;common&quot;, null); if( commonLoader == null ) { // no config file, default to this loader - we might be in a &apos;single&apos; env. commonLoader=this.getClass().getClassLoader(); } catalinaLoader = createClassLoader(&quot;server&quot;, commonLoader); sharedLoader = createClassLoader(&quot;shared&quot;, commonLoader); } catch (Throwable t) { handleThrowable(t); log.error(&quot;Class loader creation threw exception&quot;, t); System.exit(1); } }这里初始化三个类加载器，分别是commonLoader，catalinaLoader，sharedLoader并建立他们之间的关系，catalinaLoader和sharedLoader的parent是commonLoader。接下来在createClassLoader()方法看三个类加载器的创建过程 2. createClassLoader()private ClassLoader createClassLoader(String name, ClassLoader parent) throws Exception { String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;); if ((value == null) || (value.equals(&quot;&quot;))) return parent; value = replace(value); List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;(); String[] repositoryPaths = getPaths(value); for (String repository : repositoryPaths) { // Check for a JAR URL repository try { @SuppressWarnings(&quot;unused&quot;) URL url = new URL(repository); repositories.add( new Repository(repository, RepositoryType.URL)); continue; } catch (MalformedURLException e) { // Ignore } // Local repository if (repository.endsWith(&quot;*.jar&quot;)) { repository = repository.substring (0, repository.length() - &quot;*.jar&quot;.length()); repositories.add( new Repository(repository, RepositoryType.GLOB)); } else if (repository.endsWith(&quot;.jar&quot;)) { repositories.add( new Repository(repository, RepositoryType.JAR)); } else { repositories.add( new Repository(repository, RepositoryType.DIR)); } } return ClassLoaderFactory.createClassLoader(repositories, parent); }createClassLoader首先回去读取CatalinaProperties中的common.loader，server.loader，shared.loader三个属性，进入CatalinaProperties类中会发现这三个属性来自conf/catalina.properties文件。接着往下createClassLoader会将common.loader，server.loader，shared.loader三个属性中的值获取然后解析成Repository，然后交给ClassLoaderFactory.createClassLoader方法去创建类加载器，最后可以实现三个不同的类加载器分别加载不同目录下的类。 当然要说清楚的是，默认情况下，catalina.properties中server.loader，shared.loader并没有配置值，三个类加载是同一个，默认加载{catalina.home}/lib目录下的类和jar包。如果想配置对所有web应用都可见但对tomcat内部服务器不可见的类，此时应该在catalina.properties文件中的shared.loader下进行配置。 接下来我们回到init()方法中继续看下面的步骤 Thread.currentThread().setContextClassLoader(catalinaLoader)将catalinaLoader设置为Tomcat主线程的线程上下文类加载器。 3 *SecurityClassLoad.securityClassLoad(catalinaLoader)SecurityClassLoad.securityClassLoad用于线程安全的加载tomcat容器所需的class。 当然，要使这个方法真正起作用，需要启动tomcat安全管理器，由代码可知： public static void securityClassLoad(ClassLoader loader) throws Exception { securityClassLoad(loader, true); } static void securityClassLoad(ClassLoader loader, boolean requireSecurityManager) throws Exception { if (requireSecurityManager &amp;&amp; System.getSecurityManager() == null) { return; } loadCorePackage(loader); loadCoyotePackage(loader); loadLoaderPackage(loader); loadRealmPackage(loader); loadServletsPackage(loader); loadSessionPackage(loader); loadUtilPackage(loader); loadJavaxPackage(loader); loadConnectorPackage(loader); loadTomcatPackage(loader); }如果没启用安全管理器，System.getSecurityManager()=null，直接return。 可以通过命令行的方式启功安全管理器：catalina.bat run -security或者startup.bat -security 一旦启动了安全管理器，就会根据conf/catalina.policy文件定义的提供默认的安全策略，securityClassLoad方法中System.getSecurityManager()不再等于null，于是就会去执行一系列加载方法，将tomcat的class加载进来。 想了解to吗tomcat的安全策略，可以参考下这篇博文：你很少使用的安全管理SecurityManager 4. 通过反射实例化catalinainit()方法在加载完SecurityClassLoader后，就通过反射来实例化catalina，然后反射调用setParentClassLoader将sharedLoader传入到catalina实例中。 // Load our startup class and call its process() method if (log.isDebugEnabled()) log.debug(&quot;Loading startup class&quot;); Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); Object startupInstance = startupClass.getConstructor().newInstance(); // Set the shared extensions class loader if (log.isDebugEnabled()) log.debug(&quot;Setting startup class properties&quot;); String methodName = &quot;setParentClassLoader&quot;; Class&lt;?&gt; paramTypes[] = new Class[1]; paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;); Object paramValues[] = new Object[1]; paramValues[0] = sharedLoader; Method method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues); catalinaDaemon = startupInstance;为什么不直接通过Bootstrap类直接启动tomcat，而是通过反射生成Catalina实例启动？ 在查看tomcat目录结构时应该发现，Bootstrap并不在CATALINAHOME/lib目录下，而是在CATALINA_HOME/bin目录中，Bootstrap和Catalina松耦合（通过反射调用Catalina），它直接依赖JRE运行并为Tomcat应用服务器创建共享类加载器，用于构造Catalina和整个tomcat服务器。实现了启动入口和核心环境的解耦，简化了启动。 这段话目前理解不是很透彻，毕竟还属于菜鸟阶段。这里贴出一个关于反射作用的链接，勉强可以理解一下吧。Java反射机制–是什么，为什么，怎么用 setAwait()方法说完了init()方法，接下来进入mian方法的else中 else if (command.equals(&quot;start&quot;)) { daemon.setAwait(true); daemon.load(args); daemon.start(); }我们来看setAwait()方法： public void setAwait(boolean await) throws Exception { Class&lt;?&gt; paramTypes[] = new Class[1]; paramTypes[0] = Boolean.TYPE; Object paramValues[] = new Object[1]; paramValues[0] = Boolean.valueOf(await); Method method = catalinaDaemon.getClass().getMethod(&quot;setAwait&quot;, paramTypes); method.invoke(catalinaDaemon, paramValues); }通过反射调用catalina的setAwait方法，其设置的值是留给后面用的。当Catalina将Tomcat的所有组件启动之后，会检查await属性，如果为true，会调用Catalina.await()，而Catalina.await()又会调用其内部的Server的await()（代码在这里不再贴出）。 public void start() { ... if (await) { await(); stop(); } }Server.await()包含一个while循环，此循环用于监听指定socket端口(默认为8005)的连接，当某个连接传入的参数为”SHUTDOWN”(默认为”SHUTDOWN”)时，终止此while循环(端口号和终止while循环的参数，在server.xml的Server标签设置)。Server.await()用来维持Bootstrap的main方法(main thread)处于运行状态，而线程池中监听http请求的线程是守护线程(daemon thread)。 当Tomcat的指定端口接收到关闭命令时，Server.await()内的while循环终止，然后Catalina会调用stop()方法，关闭Tomcat的所有组件，最终Bootstrap的main thread终止，Tomcat关闭。 load()方法private void load(String[] arguments) throws Exception { // Call the load() method String methodName = &quot;load&quot;; Object param[]; Class&lt;?&gt; paramTypes[]; if (arguments==null || arguments.length==0) { paramTypes = null; param = null; } else { paramTypes = new Class[1]; paramTypes[0] = arguments.getClass(); param = new Object[1]; param[0] = arguments; } Method method = catalinaDaemon.getClass().getMethod(methodName, paramTypes); if (log.isDebugEnabled()) log.debug(&quot;Calling startup class &quot; + method); method.invoke(catalinaDaemon, param); }该方法通过反射调用catalina的load方法。 public void load() { if (loaded) { return; } loaded = true; long t1 = System.nanoTime(); initDirs(); // Before digester - it may be needed initNaming(); // Create and execute our Digester Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try { try { file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource(file.toURI().toURL().toString()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString(&quot;catalina.configFail&quot;, file), e); } } if (inputStream == null) { try { inputStream = getClass().getClassLoader() .getResourceAsStream(getConfigFile()); inputSource = new InputSource (getClass().getClassLoader() .getResource(getConfigFile()).toString()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString(&quot;catalina.configFail&quot;, getConfigFile()), e); } } } // This should be included in catalina.jar // Alternative: don&apos;t bother with xml, just create it manually. if (inputStream == null) { try { inputStream = getClass().getClassLoader() .getResourceAsStream(&quot;server-embed.xml&quot;); inputSource = new InputSource (getClass().getClassLoader() .getResource(&quot;server-embed.xml&quot;).toString()); } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(sm.getString(&quot;catalina.configFail&quot;, &quot;server-embed.xml&quot;), e); } } } if (inputStream == null || inputSource == null) { if (file == null) { log.warn(sm.getString(&quot;catalina.configFail&quot;, getConfigFile() + &quot;] or [server-embed.xml]&quot;)); } else { log.warn(sm.getString(&quot;catalina.configFail&quot;, file.getAbsolutePath())); if (file.exists() &amp;&amp; !file.canRead()) { log.warn(&quot;Permissions incorrect, read permission is not allowed on the file.&quot;); } } return; } try { inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); } catch (SAXParseException spe) { log.warn(&quot;Catalina.start using &quot; + getConfigFile() + &quot;: &quot; + spe.getMessage()); return; } catch (Exception e) { log.warn(&quot;Catalina.start using &quot; + getConfigFile() + &quot;: &quot; , e); return; } } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { // Ignore } } } getServer().setCatalina(this); getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile()); getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile()); // Stream redirection initStreams(); // Start the new server try { getServer().init(); } catch (LifecycleException e) { if (Boolean.getBoolean(&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;)) { throw new java.lang.Error(e); } else { log.error(&quot;Catalina.start&quot;, e); } } long t2 = System.nanoTime(); if(log.isInfoEnabled()) { log.info(&quot;Initialization processed in &quot; + ((t2 - t1) / 1000000) + &quot; ms&quot;); } }catalina的load方法首先初始化目录（initDirs）和初始化命名服务（initNaming），然后是createStartDigester（要了解这个方法，应该先了解一下Digester，它是apache的一个开源组件，通过它可以很方便的从xml文件生成java对象），该方法初始化Digester，为Xml的标签即解析模式增加处理规则rule。 关于Digester，可以参考这篇博文：利用Digester解析xml文件 来看createStartDigester方法protected Digester createStartDigester() { long t1=System.currentTimeMillis(); // Initialize the digester Digester digester = new Digester(); digester.setValidating(false); digester.setRulesValidation(true); Map&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; fakeAttributes = new HashMap&lt;&gt;(); List&lt;String&gt; attrs = new ArrayList&lt;&gt;(); attrs.add(&quot;className&quot;); fakeAttributes.put(Object.class, attrs); digester.setFakeAttributes(fakeAttributes); digester.setUseContextClassLoader(true); // Configure the actions we will be using digester.addObjectCreate(&quot;Server&quot;, &quot;org.apache.catalina.core.StandardServer&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server&quot;); digester.addSetNext(&quot;Server&quot;, &quot;setServer&quot;, &quot;org.apache.catalina.Server&quot;); digester.addObjectCreate(&quot;Server/GlobalNamingResources&quot;, &quot;org.apache.catalina.deploy.NamingResourcesImpl&quot;); digester.addSetProperties(&quot;Server/GlobalNamingResources&quot;); digester.addSetNext(&quot;Server/GlobalNamingResources&quot;, &quot;setGlobalNamingResources&quot;, &quot;org.apache.catalina.deploy.NamingResourcesImpl&quot;); digester.addObjectCreate(&quot;Server/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Listener&quot;); digester.addSetNext(&quot;Server/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); digester.addObjectCreate(&quot;Server/Service&quot;, &quot;org.apache.catalina.core.StandardService&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server/Service&quot;); digester.addSetNext(&quot;Server/Service&quot;, &quot;addService&quot;, &quot;org.apache.catalina.Service&quot;); digester.addObjectCreate(&quot;Server/Service/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Listener&quot;); digester.addSetNext(&quot;Server/Service/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); //Executor digester.addObjectCreate(&quot;Server/Service/Executor&quot;, &quot;org.apache.catalina.core.StandardThreadExecutor&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Executor&quot;); digester.addSetNext(&quot;Server/Service/Executor&quot;, &quot;addExecutor&quot;, &quot;org.apache.catalina.Executor&quot;); digester.addRule(&quot;Server/Service/Connector&quot;, new ConnectorCreateRule()); digester.addRule(&quot;Server/Service/Connector&quot;, new SetAllPropertiesRule( new String[]{&quot;executor&quot;, &quot;sslImplementationName&quot;, &quot;protocol&quot;})); digester.addSetNext(&quot;Server/Service/Connector&quot;, &quot;addConnector&quot;, &quot;org.apache.catalina.connector.Connector&quot;); digester.addObjectCreate(&quot;Server/Service/Connector/SSLHostConfig&quot;, &quot;org.apache.tomcat.util.net.SSLHostConfig&quot;); digester.addSetProperties(&quot;Server/Service/Connector/SSLHostConfig&quot;); digester.addSetNext(&quot;Server/Service/Connector/SSLHostConfig&quot;, &quot;addSslHostConfig&quot;, &quot;org.apache.tomcat.util.net.SSLHostConfig&quot;); digester.addRule(&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;, new CertificateCreateRule()); digester.addRule(&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;, new SetAllPropertiesRule(new String[]{&quot;type&quot;})); digester.addSetNext(&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;, &quot;addCertificate&quot;, &quot;org.apache.tomcat.util.net.SSLHostConfigCertificate&quot;); digester.addObjectCreate(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf&quot;, &quot;org.apache.tomcat.util.net.openssl.OpenSSLConf&quot;); digester.addSetProperties(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf&quot;); digester.addSetNext(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf&quot;, &quot;setOpenSslConf&quot;, &quot;org.apache.tomcat.util.net.openssl.OpenSSLConf&quot;); digester.addObjectCreate(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf/OpenSSLConfCmd&quot;, &quot;org.apache.tomcat.util.net.openssl.OpenSSLConfCmd&quot;); digester.addSetProperties(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf/OpenSSLConfCmd&quot;); digester.addSetNext(&quot;Server/Service/Connector/SSLHostConfig/OpenSSLConf/OpenSSLConfCmd&quot;, &quot;addCmd&quot;, &quot;org.apache.tomcat.util.net.openssl.OpenSSLConfCmd&quot;); digester.addObjectCreate(&quot;Server/Service/Connector/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Connector/Listener&quot;); digester.addSetNext(&quot;Server/Service/Connector/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); digester.addObjectCreate(&quot;Server/Service/Connector/UpgradeProtocol&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Connector/UpgradeProtocol&quot;); digester.addSetNext(&quot;Server/Service/Connector/UpgradeProtocol&quot;, &quot;addUpgradeProtocol&quot;, &quot;org.apache.coyote.UpgradeProtocol&quot;); // Add RuleSets for nested elements digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;)); digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;)); digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;)); digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;)); addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;); digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;)); // When the &apos;engine&apos; is found, set the parentClassLoader. digester.addRule(&quot;Server/Service/Engine&quot;, new SetParentClassLoaderRule(parentClassLoader)); addClusterRuleSet(digester, &quot;Server/Service/Engine/Cluster/&quot;); long t2=System.currentTimeMillis(); if (log.isDebugEnabled()) { log.debug(&quot;Digester for server.xml created &quot; + ( t2-t1 )); } return digester; }该方法初始化digester，创建一系列解析规则，然后在load方法中会调用： digester.parse(inputSource);可见digester解析的源是inputSource，而inputSource是来自于conf/server.xml： file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource(file.toURI().toURL().toString());configFile： protected File configFile() { //protected String configFile = &quot;conf/server.xml&quot;; File file = new File(configFile); if (!file.isAbsolute()) { file = new File(Bootstrap.getCatalinaBase(), configFile); } return file; }这样便创建出了StandardServer对象，接着便调用getServer().init(); getServer().init()init方法来自StandardServer的父类LifecycleBase： public final synchronized void init() throws LifecycleException { if (!state.equals(LifecycleState.NEW)) { invalidTransition(Lifecycle.BEFORE_INIT_EVENT); } try { setStateInternal(LifecycleState.INITIALIZING, null, false); initInternal(); setStateInternal(LifecycleState.INITIALIZED, null, false); } catch (Throwable t) { handleSubClassException(t, &quot;lifecycleBase.initFail&quot;, toString()); } }具体实现是在子类的initInternal方法中，在调用initInternal方法前后都会设置状态，LifecycleState.INITIALIZING代表正在初始化，LifecycleState.INITIALIZED表示初始化完成，相应会触发生命周期事件。 在StandardServer的initInternal方法中会调用子组件Services的init方法，并依次传递下去，完成所有组件的init。 可见catalina的load方法主要是根据conf/server.xml配置文件利用Digester创建服务器组件，然后调用Server的init方法，逐层次的实现所有组件的初始化。 start()方法最后看下start方法： public void start() throws Exception { if( catalinaDaemon==null ) init(); Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [] )null); method.invoke(catalinaDaemon, (Object [])null); }同样也是通过反射调用catalina的start方法： public void start() { if (getServer() == null) { load(); } if (getServer() == null) { log.fatal(&quot;Cannot start server. Server instance is not configured.&quot;); return; } long t1 = System.nanoTime(); // Start the new server try { getServer().start(); } catch (LifecycleException e) { log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;), e); try { getServer().destroy(); } catch (LifecycleException e1) { log.debug(&quot;destroy() failed for failed Server &quot;, e1); } return; } long t2 = System.nanoTime(); if(log.isInfoEnabled()) { log.info(&quot;Server startup in &quot; + ((t2 - t1) / 1000000) + &quot; ms&quot;); } // Register shutdown hook if (useShutdownHook) { if (shutdownHook == null) { shutdownHook = new CatalinaShutdownHook(); } Runtime.getRuntime().addShutdownHook(shutdownHook); // If JULI is being used, disable JULI&apos;s shutdown hook since // shutdown hooks run in parallel and log messages may be lost // if JULI&apos;s hook completes before the CatalinaShutdownHook() LogManager logManager = LogManager.getLogManager(); if (logManager instanceof ClassLoaderLogManager) { ((ClassLoaderLogManager) logManager).setUseShutdownHook( false); } } if (await) { await(); stop(); } }该方法主要触发StandardServer的start方法，StandardServer的start方法同init方法一样来自LifecycleBase，主要是改变生命周期的状态，同时触发相应的生命周期时间，具体的执行逻辑交由具体的子类startInternal方法实现： public final synchronized void start() throws LifecycleException { if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) || LifecycleState.STARTED.equals(state)) { return; } if (state.equals(LifecycleState.NEW)) { init(); } else if (state.equals(LifecycleState.FAILED)) { stop(); } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp; !state.equals(LifecycleState.STOPPED)) { invalidTransition(Lifecycle.BEFORE_START_EVENT); } try { setStateInternal(LifecycleState.STARTING_PREP, null, false); startInternal(); if (state.equals(LifecycleState.FAILED)) { // This is a &apos;controlled&apos; failure. The component put itself into the // FAILED state so call stop() to complete the clean-up. stop(); } else if (!state.equals(LifecycleState.STARTING)) { // Shouldn&apos;t be necessary but acts as a check that sub-classes are // doing what they are supposed to. invalidTransition(Lifecycle.AFTER_START_EVENT); } else { setStateInternal(LifecycleState.STARTED, null, false); } } catch (Throwable t) { // This is an &apos;uncontrolled&apos; failure so put the component into the // FAILED state and throw an exception. handleSubClassException(t, &quot;lifecycleBase.startFail&quot;, toString()); } }在StandardServer的startInternal方法中会调用子组件service的start方法，并依次调用其他组件的start方法。 protected void startInternal() throws LifecycleException { fireLifecycleEvent(CONFIGURE_START_EVENT, null); setState(LifecycleState.STARTING); globalNamingResources.start(); // Start our defined Services synchronized (servicesLock) { for (int i = 0; i &lt; services.length; i++) { services[i].start(); } } }所以同load方法很相似，start方法主要是实现各组件的start方法依次调用，可以用一张图来理解：还应该看到Catalina的start方法会使用前面的setAwait方法传递的值，为true时，会在8005端口监听，保证主线程一直在运行，直到收到SHUTDOWN命令 这里把StandardServer的await方法贴出来，目前还不是很理解其中的机制，待回来再研究一遍。 public void await() { // Negative values - don&apos;t wait on port - tomcat is embedded or we just don&apos;t like ports if( port == -2 ) { // undocumented yet - for embedding apps that are around, alive. return; } if( port==-1 ) { try { awaitThread = Thread.currentThread(); while(!stopAwait) { try { Thread.sleep( 10000 ); } catch( InterruptedException ex ) { // continue and check the flag } } } finally { awaitThread = null; } return; } // Set up a server socket to wait on try { awaitSocket = new ServerSocket(port, 1, InetAddress.getByName(address)); } catch (IOException e) { log.error(&quot;StandardServer.await: create[&quot; + address + &quot;:&quot; + port + &quot;]: &quot;, e); return; } try { awaitThread = Thread.currentThread(); // Loop waiting for a connection and a valid command while (!stopAwait) { ServerSocket serverSocket = awaitSocket; if (serverSocket == null) { break; } // Wait for the next connection Socket socket = null; StringBuilder command = new StringBuilder(); try { InputStream stream; long acceptStartTime = System.currentTimeMillis(); try { socket = serverSocket.accept(); socket.setSoTimeout(10 * 1000); // Ten seconds stream = socket.getInputStream(); } catch (SocketTimeoutException ste) { // This should never happen but bug 56684 suggests that // it does. log.warn(sm.getString(&quot;standardServer.accept.timeout&quot;, Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste); continue; } catch (AccessControlException ace) { log.warn(&quot;StandardServer.accept security exception: &quot; + ace.getMessage(), ace); continue; } catch (IOException e) { if (stopAwait) { // Wait was aborted with socket.close() break; } log.error(&quot;StandardServer.await: accept: &quot;, e); break; } // Read a set of characters from the socket int expected = 1024; // Cut off to avoid DoS attack while (expected &lt; shutdown.length()) { if (random == null) random = new Random(); expected += (random.nextInt() % 1024); } while (expected &gt; 0) { int ch = -1; try { ch = stream.read(); } catch (IOException e) { log.warn(&quot;StandardServer.await: read: &quot;, e); ch = -1; } // Control character or EOF (-1) terminates loop if (ch &lt; 32 || ch == 127) { break; } command.append((char) ch); expected--; } } finally { // Close the socket now that we are done with it try { if (socket != null) { socket.close(); } } catch (IOException e) { // Ignore } } // Match against our command string boolean match = command.toString().equals(shutdown); if (match) { log.info(sm.getString(&quot;standardServer.shutdownViaPort&quot;)); break; } else log.warn(&quot;StandardServer.await: Invalid command &apos;&quot; + command.toString() + &quot;&apos; received&quot;); } } finally { ServerSocket serverSocket = awaitSocket; awaitThread = null; awaitSocket = null; // Close the server socket and return if (serverSocket != null) { try { serverSocket.close(); } catch (IOException e) { // Ignore } } } }","link":"/2018/10/29/tomat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/15/hello-world/"},{"title":"tomcat源码解析-整体架构","text":"tomcat结构如图： Server：服务器的意思，代表整个tomcat服务器，一个tomcat只有一个Server； Service：Server中的一个逻辑功能层， 一个Server可以包含多个Service； Connector：连接器，是Service的核心组件之一，一个Service可以有多个Connector，主要是连接客户端请求； Container：Service的另一个核心组件，按照层级有Engine，Host，Context，Wrapper四种，一个Service只有一个Engine，其主要作用是执行业务逻辑； Jasper：JSP引擎； Session：会话管理 … conf/server.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;/&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot;/&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;/&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;/Realm&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot;/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt;Server一个tomcat只能有一个Server，Server中包含一个或多个Service组件，用于提供具体服务。Server在tomcat中的标准实现为：org.apache.catalina.core.StandardServer，其继承结构如下。StandardServer实现Server类，tomcat为所有的组件都提供了生命周期管理，继承LifecycleMBeanBase。 ServiceServer服务器的基本功能： 接收客户端的请求，然后解析请求，完成相应的业务逻辑，然后把处理后的结果返回给客户端，一般会提供两个节本方法，一个start打开服务Socket连接，监听服务端口，一个stop停止服务释放网络资源。 这是的服务器就是一个server类但如果将请求监听和请求处理放在一起，扩展性会变差，毕竟网络协议不止HTTP一种，如果想适配多种网络协议，请求处理又相同，这时就无能为力了，tomcat的设计大师不会采取这种做法，而是将请求监听和请求处理分开为两个模块，分别Connector和Container，Connector负责处理请求监听，Container负责处理请求处理。但显然tomcat可以有多个Connector，同时Container也可以有多个。那这就存在一个问题，哪个Connector对应哪个Container，提供复杂的映射吗？相信看过server.xml文件的人已经知道了tomcat是怎么处理的了。 没错，Service就是这样来的。在conf/server.xml文件中，可以看到Service组件包含了Connector组件和Engine组件（前面有提过，Engine就是一种容器），即Service相当于Connector和Engine组件的包装器，将一个或者多个Connector和一个Engine建立关联关系。在默认的配置文件中，定义了一个叫Catalina 的服务，它将HTTP/1.1和AJP/1.3这两个Connector与一个名为Catalina 的Engine关联起来。一个Server可以包含多个Service（它们相互独立，只是公用一个JVM及类库），一个Service负责维护多个Connector和一个Container。 Service的实现类是StandardService：这是的tomcat是这样的： ConnectorConnector是连接器，用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。 一个Connector会监听一个独立的端口来处理来自客户端的请求。server.xml默认配置了两个Connector： &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt;，它监听端口8080,这个端口值可以修改，connectionTimeout定义了连接超时时间，单位是毫秒，redirectPort 定义了ssl的重定向接口，根据上述配置，Connector会将ssl请求转发到8443端口。 &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;, AJP表示Apache Jserv Protocol，它将处理Tomcat和Apache http服务器之间的交互，此连接器用于处理我们将Tomcat和Apache http服务器结合使用的情况，如在同一台物理Server上部署一个Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡时，针对不同的Tomcat实例需要AJP监听不同的端口。 Connector在tomcat中的设计比较复杂，这里先简答介绍一下。Connector使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的（tomcat9已经删除了这个类，不再采用BIO的方式），Http11NioProtocol使用的是NioSocket来连接的。 其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。 Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request（这个Request和ServletRequest无关），Adapter充当适配器，用于将Request转换为ServletRequest交给Container进行具体的处理。 Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。 Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。 先不用太纠结，了解Connector是做什么的就可以，后续再深入。 Containertomcat的container层次如下 Engine一个Service中有多个Connector和一个Engine，Engine表示整个Servlet引擎，一个Engine下面可以包含一个或者多个Host，即一个Tomcat实例可以配置多个虚拟主机，默认的情况下 conf/server.xml 配置文件中&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;定义了一个名为Catalina的Engine。Engine的UML类图如下： HostHost，代表一个站点，也可以叫虚拟主机，一个Host可以配置多个Context，在server.xml文件中的默认配置为&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;, 其中appBase=webapps， 也就是\\webapps目录，unpackingWARS=true 属性指定在appBase指定的目录中的war包都自动的解压，autoDeploy=true 属性指定对加入到appBase目录的war包进行自动的部署。一个Engine包含多个Host的设计，使得一个服务器实例可以承担多个域名的服务，是很灵活的设计。其标准实现继承图如下： ContextContext代表一个应用程序，或者一个WEB-INF目录以及下面的web.xml文件，每个Context都有一个根路径和请求路径；与Host的区别是Context代表一个应用如，默认配置下webapps下的每个目录都是一个应用，其中ROOT目录中存放主应用，其他目录存放别的子应用，而整个webapps是一个站点。在Tomcat中通常采用如下方式创建一个Context： 在\\webapps 目录中创建一个目录dirname，此时将自动创建一个context，默认context的访问url为http://host:port/dirname，也可以通过在ContextRoot\\META-INF中创建一个context.xml文件，其中包含如下内容来指定应用的访问路径： 在server.xml文件中增加context 元素，如下：&lt;Context path=&quot;/urlpath&quot; docBase=&quot;/test/xxx&quot; reloadable=true /&gt;这样就可以通过http://host:port/urlpath访问上面配置的应用。在tomcat目录中如下：其标准实现类图如下： Wrapper一个Context可以包含多个Servlet处理不同请求，当然现在的SpringMVC框架的出现导致程序中不再是大量的Servlet，但其实本质是没变的，都是由Servlet来处理或者当作入口。在tomcat中Servlet被称为wrapper，其标准类图如下：那么为什么要用Wrapper来表示Servlet？这和tomcat的处理机制有关，为了更加灵活，便于扩展，tomcat是用管道（pipeline）和阀(valve)的形式来处理请求，所以将Servlet丢给Wrapper。这个后续再分析。那么现在tomcat就是这样的： Tomcat启动流程tomcat的启动流程很标准化，入口是BootStrap，统一按照生命周期管理接口Lifecycle的定义进行启动。首先，调用init()方法逐级初始化，接着调用start()方法进行启动，同时，每次调用伴随着生命周期状态变更事件的触发。每一级组件除完成自身的处理外，还有负责调用子组件的相关调用，组件和组件之间是松耦合的，可以通过配置进行修改。流程如下：","link":"/2018/10/01/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"},{"title":"tomcat源码解析-简介和源码编译","text":"tomcat目录结构摘录 顶层目录 RUNNING.txt：记录了tomcat的运行环境以及怎样配置参数，变量，启动等等 bin文件夹 bootstrap.jar：这个jar包是引导程序jar包，是tomcat的入口。 catalina.bat：一个重要脚本，这个脚本完成了很多基本操作，如启动、关闭等，catalina.bat都参与其中，Windows中运行。 catalina.sh：文件作用同catalina.bat，在Linux/Unix系统下运行。 catalina-tasks.xml：配置文件，主要是引入各种jar包。 configtest.bat：检测语法是否正确的脚本文件。 configtest.sh：同上。 service.bat：启动tomcat服务。和注册tomcat服务那块有关系。 setclasspath.bat：设置classpath的脚本，在catalin.bat脚本中调用，可以设置java_home,jre_home等。 shutdown.bat：主要是检查catalina.bat执行所需环境，并调用catalina.bat批处理文件关闭tomcat服务。 startup.bat：主要是检查catalina.bat执行所需环境，并调用catalina.bat 批处理文件启动tomcat服务。 tcnative-1.dll：加速器组件，可以提高性能。 tomcat-native.tar.gz：里面放的是tomcat本地的library。 tool-wrapper.bat：工具包装脚本。 version.bat：一般是用来判断系统版本获取系统版本信息等。 conf文件夹catalina.policy：当Tomcat在安全模式下运行，此文件为默认的安全策略配置。catalina.properties：catalina环境变量配置。context.xml：用于定义所有Web应用均需要加载的Context配置，如果Web应用指定了自己的context.xml，那么该文件的配置会被覆盖。logging.properties：日志配置文件，可修改日志级别和日志路径等。server.xml：核心配置文件，用于配置链接器、监听端口、处理请求的虚拟主机等，可以说，tomcat根据该配置文件创建服务器实例。tomcat-users.xml：tomcat配置用户的文件，用于定义tomcat默认用户及角色映射信息，tomcat的manage模块使用该文件中定义的用户进行安全认证。web.xml：tomcat中所有应用默认的部署描述文件，主要定义了基础Servlet和MIME映射，如果应用中不包含web.xml，tomcat将使用此文件初始化部署描述，反之，tomcat会将默认部署描述与自定义配置进行合并。server.xml详情参考：server.xml配置 源码编译 下载源码：从tomcat官网下载src版本即可。注意tomcat8对应java7，tomcat9对应java8. ant构建ant的安装这里不再赘述。运行命令前需设置tomcat-build-libs路径（否则会将编译的文件默认放到系统用户路径下的tomcat-build-libs文件夹中）。这里可以直接修改apache-tomcat-8.0.53-src文件夹下的build.properties.default文件，也可以新建文件build.properties：设置base.path=xxx\\tomcat-build-libs.xxx\\tomcat-build-libs为你自己设置的放置编译文件路径。在对应的（apache-tomcat-8.0.53-src）文件夹下，控制台运行命令ant，构建成功。此时查看源码文件夹下的output文件夹，会发现多了许多文件。 IDEA运行项目采用最常用的maven运行。 在源码文件夹下新建pom.xml文件。文件内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;Tomcat8.0&lt;/artifactId&gt; &lt;name&gt;Tomcat8.0&lt;/name&gt; &lt;version&gt;8.0&lt;/version&gt; &lt;build&gt; &lt;finalName&gt;Tomcat8.0&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;!--&lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--&lt;testResources&gt;--&gt; &lt;!--&lt;testResource&gt;--&gt; &lt;!--&lt;directory&gt;test&lt;/directory&gt;--&gt; &lt;!--&lt;/testResource&gt;--&gt; &lt;!--&lt;/testResources&gt;--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; IDEA导入项目，设置SDK为jdk1.8，运行maven compile。 配置Run菜单，点Edit Configurations，点“+”，选Application，配置如下： Main Class:org.apache.catalina.startup.Bootstrap VM Options: -Dcatalina.homeF:\\jaclon\\IDEAProjects\\apache-tomcat-8.0.53-src\\output\\build(选择output的build路径)，最后点击OK。 4.运行项目。 踩过的坑 tomcat版本和jdk版本不一致 tomcat7要用jdk6编译。 IDEA控制台（run）中文乱码问题，我的IDEA环境配置的编码是UTF-8，当我把项目编码改为GBK时，给我显示正常的报错了： 错误: 找不到或无法加载主类 Dcatalina.home=F:\\jaclon\\IDEAProjects\\catalina-home错误的原因是少了”-“当项目运行正确后，改为UTF-8，还能正常运行。ps:应该是项目哪些地方用了GBK编码或者IDEA哪些地方需要配置，还是要加强学习，java运行打的相关指令一知半解。 网上很多资料都要建立一个catalina-home文件夹 ,有的资料甚至连cataline-home中的内容从哪来的都不说，找了好多才知道是output/build的内容。那直接把-Dcatalina.home执行build就可以了。也不许要配置那么多项，只配置-Dcatalina.home一项即可。 参考链接https://blog.csdn.net/w1992wishes/article/details/79213560https://www.cnblogs.com/love-jk/p/tomcat-compile.html","link":"/2018/10/01/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%AE%80%E4%BB%8B%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"title":"tomcat源码解析-类加载机制","text":"前言下载tomcat解压后，可以在webapps目录下看到几个文件夹（这些都是web应用），webapps对应到tomcat容器中的Host，里面的文件夹则对应到Context。tomcat启动后，webapps下的所有web应用都可以提供服务。那么就有一个问题，假如webapps下有两个应用app1和app2，它们有各自独立依赖的jar包，又有共同依赖的jar包，这些相同的jar包有些版本相同，有些又不相同，这种情况下，tomcat是如何加载这些jar包的呢？ Java类加载机制简介 类加载器类加载器：虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。判断两个类相等：对于任意一个类，都需要由加载它的类加载器和这个类本身共同确定它在Java虚拟机中的唯一性，即两个类相同需要被同一个加载器加载，来源于同一个Class文件。 双亲委派模型Java 提供三种类型的系统类加载器： 启动类加载器（Bootstrap ClassLoader）：由C++语言实现，属于JVM的一部分，其作用是加载 ＜JAVA_HOME＞\\lib 目录中的文件，或者被-Xbootclasspath参数所指定的路径中的文件，并且该类加载器只加载特定名称的文件（如 rt.jar），而不是该目录下所有的文件。启动类加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：由sun.misc.Launcher.ExtClassLoader实现，它负责加载＜JAVA_HOME＞\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：也称系统类加载器，由sun.misc.Launcher.AppClassLoader实现。负责加载用户类路径（Class Path）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 用户自定义类型加载器双亲委派模式： 查找对应的类是否已经加载。 若未加载，则判断当前类加载器的父加载器是否为空，不为空则委托给父类去加载，否则调用启动类加载器加载（findBootstrapClassOrNull 再往下会调用一个 native 方法）。 若第二步加载失败，说明父类加载器无法完成加载请求 ，则调用当前类加载器加载原因：都知道java.lang.Object是java中所有类的父类，它存放在rt.jar之中，按照双亲委派模型，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。试想，如果没有使用双亲委派模型，由各个类加载器自行去加载，显然，这就存在很大风险，用户完全可以恶意编写一个java.lang.Object类，然后放到ClassPath下，那系统就会出现多个Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 打破双亲委派模型存在基础类回调用户类代码的问题。引入线程上下文类加载器（Thread Context ClassLoader）OSGI Tomcat类加载器web容器应该具备的特性不难想象，一个功能健全的Web容器，它的类加载器必然有多个，因为它应该具备如下特性： 隔离性：部署在同一个Web容器上的两个Web应用程序所使用的Java类库可以实现相互隔离。设想一下，两个Web应用，一个使用了Spring2.5，另一个使用了教新的4.0，应用服务器使用一个类加载器，Web应用将会因为jar包覆盖而无法启动。 灵活性：Web应用之间的类加载器相互独立，那么就能针对一个Web应用进行重新部署，此时Web应用的类加载器会被重建，而且不会影响其他的Web应用。如果采用一个类加载器，类之间的依赖是杂乱复杂的，无法完全移出某个应用的类。 性能：部署在同一个Web容器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求也很常见，例如，用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到Web容器的内存，如果类库不能共享，虚拟机的方法区就会很容易出现过度膨胀的风险。 Tomcat类加载器结构图示Tomcat类加载器的整体结构：可以看到在原先的java类加载器基础上，tomcat新增了几个类加载器，包括3个基础类加载器和每个Web应用的类加载器，其中3个基础类加载器可在conf/catalina.properties中配置，具体介绍下： Common：以应用类加载器为父类，是tomcat顶层的公用类加载器，其路径由conf/catalina.properties中的common.loader指定，默认指向${catalina.home}/lib下的包。 Catalina：以Common类加载器为父类，是用于加载Tomcat应用服务器的类加载器，其路径由server.loader指定，默认为空，此时tomcat使用Common类加载器加载应用服务器。 Shared：以Common类加载器为父类，是所有Web应用的父类加载器，其路径由shared.loader指定，默认为空，此时tomcat使用Common类加载器作为Web应用的父加载器。 Web应用：以Shared类加载器为父类，加载/WEB-INF/classes目录下的未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包，该类加载器只对当前Web应用可见，对其他Web应用均不可见。 默认情况下，Common、Catalina、Shared类加载器是同一个，但可以配置3个不同的类加载器，使他们各司其职。 Common类加载器复杂加载Tomcat应用服务器内部和Web应用均可见的类，如Servlet规范相关包和一些通用工具包。 Catalina类加载器负责只有Tomcat应用服务器内部可见的类，这些类对Web应用不可见。比如，想实现自己的会话存储方案，而且该方案依赖了一些第三方包，当然是不希望这些包对Web应用可见，这时可以配置server.load，创建独立的Catalina类加载器。 Shared类复杂加载Web应用共享类，这些类tomcat服务器不会依赖。 到这里，前言的问题已经解开了。 下面是第二个问题： 如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围内的用户程序呢？ 如果按主流的双亲委派机制，显然无法做到让父类加载器加载的类去访问子类加载器加载的类，但使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。spring加载类所用的Classloader是通过Thread.currentThread().getContextClassLoader()来获取的，而当线程创建时会默认setContextClassLoader(AppClassLoader)，即线程上下文类加载器被设置为AppClassLoader，spring中始终可以获取到这个AppClassLoader(**在Tomcat里就是WebAppClassLoader**)子类加载器来加载bean，以后任何一个线程都可以通过getContextClassLoader()获取到WebAppClassLoader来getbean了。 接下来，看一看源码。 Tomcat类加载器源码分析1.Common/Catalina/Shared ClassLoader的创建首先看Tomcat类加载器继承结构：相信看到这会很疑惑，这和上面介绍的tomcat类加载器结构不一样啊。是这样的，双亲委派模型本不是通过继承实现的，而是组合，所以AppClassLoader没有继承自ExtClassLoader，WebappClassLoader也没有继承自AppClassLoader。至于Common ClassLoader，Shared ClassLoader，Catalina ClassLoader则是在启动时初始化的三个不同名字的URLClassLoader。来到BootStrap中看一下： public static void main(String args[]) { if (daemon == null) { // Don&apos;t set daemon until init() has completed Bootstrap bootstrap = new Bootstrap(); try { bootstrap.init(); } catch (Throwable t) { handleThrowable(t); t.printStackTrace(); return; } daemon = bootstrap; } else { // When running as a service the call to stop will be on a new // thread so make sure the correct class loader is used to prevent // a range of class not found exceptions. Thread.currentThread().setContextClassLoader(daemon.catalinaLoader); } ... }先判断Bootstrap是否为null，不为null，直接将Catalina ClassLoader设置到当前线程，用于加载服务器相关类，为null则进入bootstrap的init方法。 public void init() throws Exception { initClassLoaders(); Thread.currentThread().setContextClassLoader(catalinaLoader); SecurityClassLoad.securityClassLoad(catalinaLoader); ... }init方法会调用initClassLoaders，同样也会将Catalina ClassLoader设置到当前线程设置到当前线程，进入initClassLoaders来看看。 private void initClassLoaders() { try { commonLoader = createClassLoader(&quot;common&quot;, null); if( commonLoader == null ) { // no config file, default to this loader - we might be in a &apos;single&apos; env. commonLoader=this.getClass().getClassLoader(); } catalinaLoader = createClassLoader(&quot;server&quot;, commonLoader); sharedLoader = createClassLoader(&quot;shared&quot;, commonLoader); } catch (Throwable t) { handleThrowable(t); log.error(&quot;Class loader creation threw exception&quot;, t); System.exit(1); } }应该就很明白了，会创建三个ClassLoader，CommClassLoader，Catalina ClassLoader，SharedClassLoader，正好对应前面介绍的三个基础类加载器。再进入createClassLoader可以看到这三个基础类加载器所加载的资源刚好对应conf/catalina.properties中的common.loader，server.loader，shared.loader： private ClassLoader createClassLoader(String name, ClassLoader parent) throws Exception { String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;); if ((value == null) || (value.equals(&quot;&quot;))) return parent; value = replace(value); List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;(); String[] repositoryPaths = getPaths(value); for (String repository : repositoryPaths) { // Check for a JAR URL repository try { @SuppressWarnings(&quot;unused&quot;) URL url = new URL(repository); repositories.add( new Repository(repository, RepositoryType.URL)); continue; } catch (MalformedURLException e) { // Ignore } // Local repository if (repository.endsWith(&quot;*.jar&quot;)) { repository = repository.substring (0, repository.length() - &quot;*.jar&quot;.length()); repositories.add( new Repository(repository, RepositoryType.GLOB)); } else if (repository.endsWith(&quot;.jar&quot;)) { repositories.add( new Repository(repository, RepositoryType.JAR)); } else { repositories.add( new Repository(repository, RepositoryType.DIR)); } } return ClassLoaderFactory.createClassLoader(repositories, parent); }再进入ClassLoaderFactory.createClassLoader()方法中，可以看到，构建的是URLClassLoader。 public static ClassLoader createClassLoader(List&lt;Repository&gt; repositories, final ClassLoader parent) throws Exception { ... // Construct the &quot;class path&quot; for this class loader ... // Construct the class loader itself final URL[] array = set.toArray(new URL[set.size()]); if (log.isDebugEnabled()) for (int i = 0; i &lt; array.length; i++) { log.debug(&quot; location &quot; + i + &quot; is &quot; + array[i]); } return AccessController.doPrivileged( new PrivilegedAction&lt;URLClassLoader&gt;() { @Override public URLClassLoader run() { if (parent == null) return new URLClassLoader(array); else return new URLClassLoader(array, parent); } }); } Common/Catalina/Shared ClassLoader的层次构建Common/Catalina/Shared ClassLoader的创建好了，肯定是要被使用的，是在哪里使用的呢？它们之间同Webapp ClassLoader又是怎么联系起来的？回到bootstrap的init()方法创建完成后会将ShareClassLoader通过反射调用Catalina类setParentClassLoader方法设置到parentClassLoader属性中，然后在解析方法中再设置到Engine容器中去，部分代码如下： // Add RuleSets for nested elementsdigester.addRuleSet(new NamingRuleSet(“Server/GlobalNamingResources/“));digester.addRuleSet(new EngineRuleSet(“Server/Service/“)); digester.addRuleSet(new HostRuleSet(“Server/Service/Engine/“)); digester.addRuleSet(new ContextRuleSet(“Server/Service/Engine/Host/“)); addClusterRuleSet(digester, “Server/Service/Engine/Host/Cluster/“); digester.addRuleSet(new NamingRuleSet(“Server/Service/Engine/Host/Context/“)); // When the ‘engine’ is found, set the parentClassLoader.digester.addRule(“Server/Service/Engine”,new SetParentClassLoaderRule(parentClassLoader));既然sharedClassLoader被传入到Catalina中，就来看它的getParentClassLoader调用栈。经过层层调用，来到StandardContext的startInternal方法，这个方法很长很复杂，就不全贴出来，里面有这样一段： if (getLoader() == null) { WebappLoader webappLoader = new WebappLoader(getParentClassLoader()); webappLoader.setDelegate(getDelegate()); setLoader(webappLoader); }它会创建WebappLoader对象，并通过setLoader(webappLoader)赋值到一个实例变量中，然后会调用WebappLoader的start方法: … if (ok) { // Start our subordinate components, if any Loader loader = getLoader(); if (loader instanceof Lifecycle) { ((Lifecycle) loader).start(); } ... } …这里关系到tomcat的生命周期机制，先不纠结，直接找到start方法，start方法是在父类中，最后要调回到WebappLoader中的startInternal方法。该方法中有这样一段： … classLoader = createClassLoader(); classLoader.setResources(context.getResources()); classLoader.setDelegate(this.delegate); …进入createClassLoader方法： private WebappClassLoaderBase createClassLoader() throws Exception { // private String loaderClass = ParallelWebappClassLoader.class.getName(); Class&lt;?&gt; clazz = Class.forName(loaderClass); WebappClassLoaderBase classLoader = null; if (parentClassLoader == null) { parentClassLoader = context.getParentClassLoader(); } Class&lt;?&gt;[] argTypes = { ClassLoader.class }; Object[] args = { parentClassLoader }; Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes); classLoader = (WebappClassLoaderBase) constr.newInstance(args); return classLoader; }该方法会实例化一个ParallelWebappClassLoader实例，并且传递了sharedLoader作为其父亲加载器。 代码阅读到这里，已经基本清楚了Tomcat中ClassLoader的总体结构，总结如下： 在Tomcat存在common、cataina、shared三个公共的classloader,默认情况下，这三个classloader其实是同一个，都是common classloader，而针对每个webapp，也就是context（对应代码中的StandardContext类），都有自己的WebappClassLoader实例来加载每个应用自己的类，该类加载实例的parent即是Shared ClassLoader。 这样前面关于tomcat的类加载层次应该就清楚起来了 tomcat类加载器的加载过程借tomcat官网上的话总结一下：Web应用类加载器默认的加载顺序是：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；(4).如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是AppClassLoader、Common、Shared。tomcat提供了delegate属性用于控制是否启用java委派模式，默认false（不启用），当设置为true时，tomcat将使用java的默认委派模式，这时加载顺序如下：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从父类加载器加载，加载顺序是AppClassLoader、Common、Shared。(4).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）； public Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { if (log.isDebugEnabled()) log.debug(&quot;loadClass(&quot; + name + &quot;, &quot; + resolve + &quot;)&quot;); Class&lt;?&gt; clazz = null; // Log access to stopped class loader checkStateForClassLoading(name); // (0) Check our previously loaded local class cache clazz = findLoadedClass0(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(&quot; Returning class from cache&quot;); if (resolve) resolveClass(clazz); return clazz; } // (0.1) Check our previously loaded class cache clazz = findLoadedClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(&quot; Returning class from cache&quot;); if (resolve) resolveClass(clazz); return clazz; } // (0.2) Try loading the class with the system class loader, to prevent // the webapp from overriding Java SE classes. This implements // SRV.10.7.2 String resourceName = binaryNameToPath(name, false); ClassLoader javaseLoader = getJavaseClassLoader(); boolean tryLoadingFromJavaseLoader; try { // Use getResource as it won&apos;t trigger an expensive // ClassNotFoundException if the resource is not available from // the Java SE class loader. However (see // https://bz.apache.org/bugzilla/show_bug.cgi?id=58125 for // details) when running under a security manager in rare cases // this call may trigger a ClassCircularityError. // See https://bz.apache.org/bugzilla/show_bug.cgi?id=61424 for // details of how this may trigger a StackOverflowError // Given these reported errors, catch Throwable to ensure any // other edge cases are also caught tryLoadingFromJavaseLoader = (javaseLoader.getResource(resourceName) != null); } catch (Throwable t) { // Swallow all exceptions apart from those that must be re-thrown ExceptionUtils.handleThrowable(t); // The getResource() trick won&apos;t work for this class. We have to // try loading it directly and accept that we might get a // ClassNotFoundException. tryLoadingFromJavaseLoader = true; } if (tryLoadingFromJavaseLoader) { try { clazz = javaseLoader.loadClass(name); if (clazz != null) { if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } } // (0.5) Permission to access this class when using a SecurityManager if (securityManager != null) { int i = name.lastIndexOf(&apos;.&apos;); if (i &gt;= 0) { try { securityManager.checkPackageAccess(name.substring(0,i)); } catch (SecurityException se) { String error = &quot;Security Violation, attempt to use &quot; + &quot;Restricted Class: &quot; + name; log.info(error, se); throw new ClassNotFoundException(error, se); } } } boolean delegateLoad = delegate || filter(name, true); // (1) Delegate to our parent if requested if (delegateLoad) { if (log.isDebugEnabled()) log.debug(&quot; Delegating to parent classloader1 &quot; + parent); try { clazz = Class.forName(name, false, parent); if (clazz != null) { if (log.isDebugEnabled()) log.debug(&quot; Loading class from parent&quot;); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } } // (2) Search local repositories if (log.isDebugEnabled()) log.debug(&quot; Searching local repositories&quot;); try { clazz = findClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(&quot; Loading class from local repository&quot;); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } // (3) Delegate to parent unconditionally if (!delegateLoad) { if (log.isDebugEnabled()) log.debug(&quot; Delegating to parent classloader at end: &quot; + parent); try { clazz = Class.forName(name, false, parent); if (clazz != null) { if (log.isDebugEnabled()) log.debug(&quot; Loading class from parent&quot;); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } } } throw new ClassNotFoundException(name); }分析加载过程：ParallelWebappClassLoader的loadClass是在其父类WebappClassLoaderBase中实现的。第一步：首先调用findLoaderClass0() 方法检查WebappClassLoader中是否加载过此类。WebappClassLoader 加载过的类都存放在 resourceEntries 缓存中. protected final Map&lt;String, ResourceEntry&gt; resourceEntries = new ConcurrentHashMap&lt;&gt;();第二步：检查缓存中是否加载过此类。 clazz = findLoadedClass(name);第三步：使用javaseClassLoader ClassLoader javaseLoader = getJavaseClassLoader(); boolean tryLoadingFromJavaseLoader; try { // Use getResource as it won&apos;t trigger an expensive // ClassNotFoundException if the resource is not available from // the Java SE class loader. However (see // https://bz.apache.org/bugzilla/show_bug.cgi?id=58125 for // details) when running under a security manager in rare cases // this call may trigger a ClassCircularityError. // See https://bz.apache.org/bugzilla/show_bug.cgi?id=61424 for // details of how this may trigger a StackOverflowError // Given these reported errors, catch Throwable to ensure any // other edge cases are also caught tryLoadingFromJavaseLoader = (javaseLoader.getResource(resourceName) != null); } catch (Throwable t) { // Swallow all exceptions apart from those that must be re-thrown ExceptionUtils.handleThrowable(t); // The getResource() trick won&apos;t work for this class. We have to // try loading it diretly and accept that we might get a // ClassNotFoundException. tryLoadingFromJavaseLoader = true; } if (tryLoadingFromJavaseLoader) { try { clazz = javaseLoader.loadClass(name); if (clazzc != null) { if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } }第四步：先判断是否设置了delegate属性，设置为true，那么就会完全按照JVM的”双亲委托”机制流程加载类。否则，先使用WebappClassLoader自己处理加载类的。当然，若是委托了使用双亲委托亦没有加载到class实例，那还是最后使用WebappClassLoader加载。第五步：若是没有委托，则默认会首次使用WebappClassLoader来加载类。通过自定义findClass定义处理类加载规则。findClass()会去Web-INF/classes 目录下查找类。去阅读里面的代码，里面有这样一个方法： @Override public WebResource getClassLoaderResource(String path) { return getResource(&quot;/WEB-INF/classes&quot; + path, true, true); }第六步：若是WebappClassLoader在/WEB-INF/classes、/WEB-INF/lib下还是查找不到class，那么无条件强制委托给System、Common类加载器去查找该类。 几个问题 Application ClassLoader是系统默认应用加载器（这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器）。它负责加载用户类路径（Class Path）上所指定的类库，Bootstrap类就是由它加载 为什么java文件放在Eclipse中的src文件夹下会优先jar包中的class? 这是因为Eclipse中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在 WEB-INF/class 中。 而Eclipse外部引用的jar包，则相当于放在 WEB-INF/lib 中。 因此肯定是 java文件或者JSP文件编译出的class优先加载。 通过这样，我们就可以简单的把java文件放置在src文件夹中，通过对该java文件的修改以及调试，便于学习拥有源码java文件、却没有打包成xxx-source的jar包。 另外呢，开发者也会因为粗心而犯下面的错误。 在 CATALINA_HOME/lib 以及 WEB-INF/lib 中放置了 不同版本的jar包，此时就会导致某些情况下报加载不到类的错误。 还有如果多个应用使用同一jar包文件，当放置了多份，就可能导致 多个应用间 出现类加载不到的错误。 每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。 当应用需要到某个类时，则会按照下面的顺序进行类加载： 1 使用bootstrap引导类加载器加载 2 使用system系统类加载器加载 3 使用应用类加载器在WEB-INF/classes中加载 4 使用应用类加载器在WEB-INF/lib中加载 5 使用common类加载器在CATALINA_HOME/lib中加载 参考链接：类加载器详细扩展JSP加载器和Tomcat加载过程相关类加载过程解释","link":"/2018/10/08/tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"tomcat源码解析-Server的创建","text":"digester规则补充本篇将聚焦server.xml的解析，介绍Server的整个创建过程。不过在这之前又整理了一下关于digester解析的内容，如果有需要可以参考一下几篇内容：https://blog.csdn.net/qq_24451605/article/details/51289519https://blog.csdn.net/caihaijiang/article/details/5944955http://commons.apache.org/proper/commons-digester/guide/core.html addObjectCreate三个参数创建对象方法第三个参数的含义： public void addObjectCreate( String pattern , String className , String attributeName ) pattern - Element matching pattern className - Default Java class name to be created attributeName - Attribute name that optionally overrides the default Java class name to be created覆盖第二个参数java class的默认类名，可以将第二个参数置为null，使用第三个参数设置类名，这样可以配置多个相同类型对象：例如配置多个生命周期监听器。 addSetNext 第三个参数的作用 public void addSetNext(String pattern,String methodName,String paramType) paramType - Java class name of the expected parameter type (if you wish to use a primitive type, specify the corresonding Java wrapper class instead, such as java.lang.Boolean for a boolean parameter)设置期望的class类型 Server的解析要了解Server的创建，就需要回到前面关于Tomcat启动过程文章中介绍的Catalina中的load方法，在load方法中会解析conf/server.xml配置文件。 前面有提到，Tomcat是使用Digester解析server.xml的，Digester的解析规则是在Catalina类的createStartDigester方法中。 简单分析下该方法。 // 首先实例化一个Digester对象 Digester digester = new Digester(); // 设置为false表示解析xml时不需要进行DTD的规则校验 digester.setValidating(false); // 是否进行节点设置规则校验,如果xml中相应节点没有设置解析规则会在控制台显示提示信息 digester.setRulesValidation(true);创建Server实例 // Configure the actions we will be using digester.addObjectCreate(&quot;Server&quot;, &quot;org.apache.catalina.core.StandardServer&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server&quot;); digester.addSetNext(&quot;Server&quot;, &quot;setServer&quot;, &quot;org.apache.catalina.Server&quot;);默认的Server实现类是org.apache.catalina.core.StandardServer，也可以在server.xml的server标签上配置className指定自己的实现。创建Server实例后，然后设置Server相关属性，然后调用栈顶对象（即该Server）之后的对象（是前面通过push(this)放入的Catalina实例）的setServer方法，将server实例设置到Catalina对象中。 digester.addObjectCreate(&quot;Server/GlobalNamingResources&quot;, &quot;org.apache.catalina.deploy.NamingResourcesImpl&quot;); digester.addSetProperties(&quot;Server/GlobalNamingResources&quot;); digester.addSetNext(&quot;Server/GlobalNamingResources&quot;, &quot;setGlobalNamingResources&quot;, &quot;org.apache.catalina.deploy.NamingResourcesImpl&quot;);GlobalNamingResources：全局命名资源定义JNDI(Java Naming and Directory Interface,Java 命名和目录接口）资源，其允许 Java 软件客户端通过名称搜寻和查找数据。在server.xml中默认配置定义了一个名称为 UserDatabase 的 JNDI，通过”conf/tomcat-users.xml“得到了一个用于用户授权的内存数据库。 &lt;--server.xml--&gt; &lt;GlobalNamingResources&gt; &lt;!-- Editable user database that can also be used by UserDatabaseRealm to authenticate users --&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot; /&gt; &lt;/GlobalNamingResources&gt; digester.addObjectCreate(&quot;Server/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Listener&quot;); digester.addSetNext(&quot;Server/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;);接着为Server实例添加生命周期监听器，默认的server.xml中配置了5个生命周期监听器。 &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;/&gt; &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;/&gt;也可以自己写一个监听器，在server.xml中配置： public class MyListener implements LifecycleListener { @Override public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.START_EVENT.equals(event.getType())){ test(); } } private void test() { System.out.println(&quot;====================================&quot;); System.out.println(&quot;test test test&quot;); System.out.println(&quot;====================================&quot;); } }创建Service实例//创建Service实例，默认是org.apache.catalina.core.StandardService digester.addObjectCreate(&quot;Server/Service&quot;, &quot;org.apache.catalina.core.StandardService&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server/Service&quot;); digester.addSetNext(&quot;Server/Service&quot;, &quot;addService&quot;, &quot;org.apache.catalina.Service&quot;); //addLifecycleListener为Service增加生命周期监听器，默认情况下，service没指定监听器。 digester.addObjectCreate(&quot;Server/Service/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Listener&quot;); digester.addSetNext(&quot;Server/Service/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); //Executor 默认为org.apache.catalina.core.StandardThreadExecutor，并将其设置到Service实例中，默认情况下，未配置Executor。 digester.addObjectCreate(&quot;Server/Service/Executor&quot;, &quot;org.apache.catalina.core.StandardThreadExecutor&quot;, &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Executor&quot;); digester.addSetNext(&quot;Server/Service/Executor&quot;, &quot;addExecutor&quot;, &quot;org.apache.catalina.Executor&quot;); //为Service实例添加Connector digester.addRule(&quot;Server/Service/Connector&quot;, new ConnectorCreateRule()); digester.addRule(&quot;Server/Service/Connector&quot;, new SetAllPropertiesRule(new String[]{&quot;executor&quot;})); digester.addSetNext(&quot;Server/Service/Connector&quot;, &quot;addConnector&quot;, &quot;org.apache.catalina.connector.Connector&quot;); //为Connector添加监听器，默认未指定。 digester.addObjectCreate(&quot;Server/Service/Connector/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(&quot;Server/Service/Connector/Listener&quot;); digester.addSetNext(&quot;Server/Service/Connector/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); // Add RuleSets for nested elements //指定了Servlet容器相关的各级嵌套子节点的解析规则，这里重点关注Engine和Host的解析，它们的解析和Context密切相关。 digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;)); digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;)); digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;)); digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;)); addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;); digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;)); // When the &apos;engine&apos; is found, set the parentClassLoader. digester.addRule(&quot;Server/Service/Engine&quot;, new SetParentClassLoaderRule(parentClassLoader)); addClusterRuleSet(digester, &quot;Server/Service/Engine/Cluster/&quot;);在设置Connector相关属性时，会判断server.xml中是否指定了executor属性，如果是，会从Service中查找该名称的Executor设置到Connector中。同时，在创建Connector时，也会判断是否有sslImplementationName属性，如果有，设置到使用的协议中，为其指定一个SSL实现。 Engine的解析Engine的解析过程在EngineRuleSet类的addRuleInstances方法中。 @Override public void addRuleInstances(Digester digester) { //创建Engine实例，默认是org.apache.catalina.core.StandardEngine. digester.addObjectCreate(prefix + &quot;Engine&quot;, &quot;org.apache.catalina.core.StandardEngine&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Engine&quot;); //给Engine添加一个生命周期监听器，默认是org.apache.catalina.startup.EngineConfig，用于打印Engine启动和停止日志，然后将该Engine实例设置到Service中。 需要说明的是EngineConfig生命监听器不是在server.xml配置的，而是在创建Engine是默认添加的。 digester.addRule(prefix + &quot;Engine&quot;, new LifecycleListenerRule (&quot;org.apache.catalina.startup.EngineConfig&quot;, &quot;engineConfigClass&quot;)); digester.addSetNext(prefix + &quot;Engine&quot;, &quot;setContainer&quot;, &quot;org.apache.catalina.Container&quot;); //Cluster configuration start 这段是为Engine创建集群配置 digester.addObjectCreate(prefix + &quot;Engine/Cluster&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Engine/Cluster&quot;); digester.addSetNext(prefix + &quot;Engine/Cluster&quot;, &quot;setCluster&quot;, &quot;org.apache.catalina.Cluster&quot;); //Cluster configuration end //和EngineConfig不同，此处的生命周期监听器是在server.xml中配置的，默认未指定。 digester.addObjectCreate(prefix + &quot;Engine/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Engine/Listener&quot;); digester.addSetNext(prefix + &quot;Engine/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); //为Engine添加realm和valve,realm和tomcat安全相关，valve同tomcat处理请求方式相关。 digester.addRuleSet(new RealmRuleSet(prefix + &quot;Engine/&quot;)); digester.addObjectCreate(prefix + &quot;Engine/Valve&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Engine/Valve&quot;); digester.addSetNext(prefix + &quot;Engine/Valve&quot;, &quot;addValve&quot;, &quot;org.apache.catalina.Valve&quot;); }Host解析Host的解析，是在HostRuleSet类的addRuleInstances方法中 @Override public void addRuleInstances(Digester digester) { digester.addObjectCreate(prefix + &quot;Host&quot;, &quot;org.apache.catalina.core.StandardHost&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Host&quot;); digester.addRule(prefix + &quot;Host&quot;, new CopyParentClassLoaderRule()); digester.addRule(prefix + &quot;Host&quot;, new LifecycleListenerRule (&quot;org.apache.catalina.startup.HostConfig&quot;, &quot;hostConfigClass&quot;)); digester.addSetNext(prefix + &quot;Host&quot;, &quot;addChild&quot;, &quot;org.apache.catalina.Container&quot;); digester.addCallMethod(prefix + &quot;Host/Alias&quot;, &quot;addAlias&quot;, 0); //Cluster configuration start digester.addObjectCreate(prefix + &quot;Host/Cluster&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Host/Cluster&quot;); digester.addSetNext(prefix + &quot;Host/Cluster&quot;, &quot;setCluster&quot;, &quot;org.apache.catalina.Cluster&quot;); //Cluster configuration end digester.addObjectCreate(prefix + &quot;Host/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Host/Listener&quot;); digester.addSetNext(prefix + &quot;Host/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); digester.addRuleSet(new RealmRuleSet(prefix + &quot;Host/&quot;)); digester.addObjectCreate(prefix + &quot;Host/Valve&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Host/Valve&quot;); digester.addSetNext(prefix + &quot;Host/Valve&quot;, &quot;addValve&quot;, &quot;org.apache.catalina.Valve&quot;); }创建默认为org.apache.catalina.core.StandardHost的实例，并将host标签上的属性设置到host实例中。接着调用Host实例中的setParentClassLoader将Engine中getParentClassLoader方法的类加载设置进来。 同Engine一样，在创建Host时，默认会添加一个生命周期监听器HostConfig，该生命周期监听器比EngineConfig复杂得多，和web应用的加载有关，将在下一篇介绍。 从配置文件中可以看到默认的Valve为AccessLogValve，用于在处理请求时记录访问日志。 Context解析最后看下Context的解析，在ContextRuleSet的addRuleInstances方法中。 首先应该明白，Context配置并非来源一处，在Tomcat的conf目录下和Web应用的META-INF目录下都有Context.xml配置文件，而且在server.xml中也可以配置Context标签。多数情况并不需要在server.xml中配置Context，更多是由HostConfig自动扫描部署目录，以Context.xml文件为基础进行Context的创建，具体将在下篇介绍。而这里是指根据server.xml配置的Context进行解析。 由于方法比较长，我们分步骤解析 Context实例化 @Override public void addRuleInstances(Digester digester) { if (create) { digester.addObjectCreate(prefix + &quot;Context&quot;, &quot;org.apache.catalina.core.StandardContext&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context&quot;); } else { digester.addRule(prefix + &quot;Context&quot;, new SetContextPropertiesRule()); } if (create) { digester.addRule(prefix + &quot;Context&quot;, new LifecycleListenerRule (&quot;org.apache.catalina.startup.ContextConfig&quot;, &quot;configClass&quot;)); digester.addSetNext(prefix + &quot;Context&quot;, &quot;addChild&quot;, &quot;org.apache.catalina.Container&quot;); }Context的解析因create不同而不同。通过server.xml配置Context时，create为true，这时默认会创建org.apache.catalina.core.StandardContext的实例。通过HostConfig自动创建Context时，create为false，此时仅解析子节点即可。如果create为true，在创建Context同时，会为context实例添加一个生命周期监听器ContextConfig，用于详细配置Context，如解析web.xml等。 为Context添加生命周期监听器 digester.addObjectCreate(prefix + &quot;Context/Listener&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Listener&quot;); digester.addSetNext(prefix + &quot;Context/Listener&quot;, &quot;addLifecycleListener&quot;, &quot;org.apache.catalina.LifecycleListener&quot;); 为Context指定类加载器 digester.addObjectCreate(prefix + &quot;Context/Loader&quot;, &quot;org.apache.catalina.loader.WebappLoader&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Loader&quot;); digester.addSetNext(prefix + &quot;Context/Loader&quot;, &quot;setLoader&quot;, &quot;org.apache.catalina.Loader&quot;); 为Context指定会话管理器 digester.addObjectCreate(prefix + &quot;Context/Manager&quot;, &quot;org.apache.catalina.session.StandardManager&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Manager&quot;); digester.addSetNext(prefix + &quot;Context/Manager&quot;, &quot;setManager&quot;, &quot;org.apache.catalina.Manager&quot;); digester.addObjectCreate(prefix + &quot;Context/Manager/Store&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Manager/Store&quot;); digester.addSetNext(prefix + &quot;Context/Manager/Store&quot;, &quot;setStore&quot;, &quot;org.apache.catalina.Store&quot;); digester.addObjectCreate(prefix + &quot;Context/Manager/SessionIdGenerator&quot;, &quot;org.apache.catalina.util.StandardSessionIdGenerator&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Manager/SessionIdGenerator&quot;); digester.addSetNext(prefix + &quot;Context/Manager/SessionIdGenerator&quot;, &quot;setSessionIdGenerator&quot;, &quot;org.apache.catalina.SessionIdGenerator&quot;);默认的会话管理器为org.apache.catalina.session.StandardManager，同时为管理器指定会话存储方式和会话标识生成器。 为Context添加初始化参数 digester.addObjectCreate(prefix + &quot;Context/Parameter&quot;, &quot;org.apache.tomcat.util.descriptor.web.ApplicationParameter&quot;); digester.addSetProperties(prefix + &quot;Context/Parameter&quot;); digester.addSetNext(prefix + &quot;Context/Parameter&quot;, &quot;addApplicationParameter&quot;, &quot;org.apache.tomcat.util.descriptor.web.ApplicationParameter&quot;); 为Context添加安全配置和Web资源配置 digester.addRuleSet(new RealmRuleSet(prefix + &quot;Context/&quot;)); digester.addObjectCreate(prefix + &quot;Context/Resources&quot;, &quot;org.apache.catalina.webresources.StandardRoot&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Resources&quot;); digester.addSetNext(prefix + &quot;Context/Resources&quot;, &quot;setResources&quot;, &quot;org.apache.catalina.WebResourceRoot&quot;); digester.addObjectCreate(prefix + &quot;Context/Resources/PreResources&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Resources/PreResources&quot;); digester.addSetNext(prefix + &quot;Context/Resources/PreResources&quot;, &quot;addPreResources&quot;, &quot;org.apache.catalina.WebResourceSet&quot;); digester.addObjectCreate(prefix + &quot;Context/Resources/JarResources&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Resources/JarResources&quot;); digester.addSetNext(prefix + &quot;Context/Resources/JarResources&quot;, &quot;addJarResources&quot;, &quot;org.apache.catalina.WebResourceSet&quot;); digester.addObjectCreate(prefix + &quot;Context/Resources/PostResources&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Resources/PostResources&quot;); digester.addSetNext(prefix + &quot;Context/Resources/PostResources&quot;, &quot;addPostResources&quot;, &quot;org.apache.catalina.WebResourceSet&quot;); digester.addObjectCreate(prefix + &quot;Context/ResourceLink&quot;, &quot;org.apache.tomcat.util.descriptor.web.ContextResourceLink&quot;); digester.addSetProperties(prefix + &quot;Context/ResourceLink&quot;); digester.addRule(prefix + &quot;Context/ResourceLink&quot;, new SetNextNamingRule(&quot;addResourceLink&quot;, &quot;org.apache.tomcat.util.descriptor.web.ContextResourceLink&quot;)); 为Context添加Valve digester.addObjectCreate(prefix + &quot;Context/Valve&quot;, null, // MUST be specified in the element &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/Valve&quot;); digester.addSetNext(prefix + &quot;Context/Valve&quot;, &quot;addValve&quot;, &quot;org.apache.catalina.Valve&quot;); 为Context添加守护资源配置 digester.addCallMethod(prefix + &quot;Context/WatchedResource&quot;, &quot;addWatchedResource&quot;, 0); digester.addCallMethod(prefix + &quot;Context/WrapperLifecycle&quot;, &quot;addWrapperLifecycle&quot;, 0); digester.addCallMethod(prefix + &quot;Context/WrapperListener&quot;, &quot;addWrapperListener&quot;, 0); digester.addObjectCreate(prefix + &quot;Context/JarScanner&quot;, &quot;org.apache.tomcat.util.scan.StandardJarScanner&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/JarScanner&quot;); digester.addSetNext(prefix + &quot;Context/JarScanner&quot;, &quot;setJarScanner&quot;, &quot;org.apache.tomcat.JarScanner&quot;); digester.addObjectCreate(prefix + &quot;Context/JarScanner/JarScanFilter&quot;, &quot;org.apache.tomcat.util.scan.StandardJarScanFilter&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/JarScanner/JarScanFilter&quot;); digester.addSetNext(prefix + &quot;Context/JarScanner/JarScanFilter&quot;, &quot;setJarScanFilter&quot;, &quot;org.apache.tomcat.JarScanFilter&quot;);WatchedResource标签可在Context.xml中找到，用于为Context添加监资源，当这些资源发生变化时，Web应用会被重新加载，默认为WEB-INF/web.xml。WrapperListener标签用于为Context添加一个生命周期类，此类的实例不是添加到Context中，而是Context包含的Wrapper。JarScanner标签为JarScanner指定一jar扫描器，JarScanFilter则为扫描器指定一个过滤器，只有符合条件的jar包才会被处理。 为Context添加Cookie处理器 digester.addObjectCreate(prefix + &quot;Context/CookieProcessor&quot;, &quot;org.apache.tomcat.util.http.LegacyCookieProcessor&quot;, &quot;className&quot;); digester.addSetProperties(prefix + &quot;Context/CookieProcessor&quot;); digester.addSetNext(prefix + &quot;Context/CookieProcessor&quot;, &quot;setCookieProcessor&quot;, &quot;org.apache.tomcat.util.http.CookieProcessor&quot;); } 小总结本篇主要写了Server创建过程中Digester类createStartDigester方法中需要创建的各种资源，对Sever创建过程有了大概的了解， 对server.xml文件各个配置都已经清楚了。也熟悉了Digester的用法，并对GlobalNamingResources和JNDI有了初步了解。","link":"/2018/11/04/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Server%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"title":"U6-类文件结构","text":"class文件程序编译后的结果： - 二进制本地机器码(0 1) - 与操作系统和机器指令集无关的、平台中立的一种格式——字节码文件(.class) 各种运行在不同平台上的虚拟机都使用同一种字节码文件。后来发展到了语言无关性，各种不同语言编译为用一种字节码文件。 class文件结构任何一个class文件都唯一对应着一个类或接口。反之则不然(比如类可以又类加载器直接生成) class文件是一组以8位字节为基础的二进制流。当要表示的数据占用空间大于8位字节时，采用高位在前的方式分割成若干个8位字节进行存储。高位在前：Big-Endian 最高位字节在地址最低位字节：一个字节包含8个二级制位，字节-Byte-B比特（bit)又称为二进制位，简称位-b,代表一个0或1 数据存储是以“字节”（Byte）为单位，数据传输大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。 class文件数据类型：无符号数和表 - 无符号数： u1 u2 u4 u8 分别表示1个字节~8个字节的基本数据类型，用来描述数字，索引引用，数量值，字符串值 - 表：由多个无符号数和其它表构成 _info结尾 class文件格式（见$P_{165}$） 表头（魔数，版本信息） 常量池 访问标志，类索引和父类索引集合 接口表集合，字段表集合，方法表集合，属性表集合 1. 魔数与class文件版本 Magic Number： u4 标志文件类型信息：是否是class文件（JPG文件、GIF文件。。。） 0XCAFEBABE “咖啡宝贝” Minor Version： 次版本号 Major Version :主版本号 2. 常量池信息记录这个文件中出现过的所有的类，方法，字段等的组成和结构。 容量计数器（constant_pool_count）记录常量池中共有多少项，从1开始而不是从0开始。例如常量池容量技术器值为22，表示共有21项常量，索引范围从1~21。将第0项索引空出来是为了表达“不引用常量池中的一项”时，将索引值置为0。 字面量和符号引用常量池中主要存放两大类常量。 字面量（Literal）：文本字符串，声明为final类型的常量值等 符号引用（Symbolic Reference）： - 类和接口的全限定名（Fully Qualified Name） - 字段和名称的描述符（Descriptor） - 方法的名称和描述符java在编译的时候没有连接这个步骤，字段和方法的具体内存地址要在类创建时、运行时确定。 常量池中的14中项目（表）类型（见$P_{169}$)共同特点：表的开始是一个u1类型的标志位，代表这个表是那种类型。主要包含： UTF-8编码的字符串 整型、浮点型……字面量 类或接口的符号引用 字符串类型字面量 字段、类中方法、接口中方法的符号引用，字段或方法的具体符号引用 jdk1.7以后动态标识方法信息的表类型：方法句柄、方法类型、动态调用点 例（P$_{170}$）Constant_Class_info和Constant_Utf-8_info类型常量结构 java中方法、字段名的最大长度为Constant_Utf-8_info类型表所能表示的最大值（U2)-65535，即程序中不能定义超过64KB的英文字符 14中常量项的结构表（P$_{172}$） 3. 访问标志（access_flags)识别类或接口层次的访问信息，包括：是否public，final，abstract等等。占两个字节，目前定义了8个，由8个标志求|得出最终值。（P$_{173}$） 4. 类索引、父类索引与接口索引集合 类索引（this_class):u2 指向Constant_Class_Info类描述符常量-指向Constant_Utf-8_info类型常量中的全限定名字符串。 父类索引（super_class): u2类型，java中单继承，所以父类索引只有一个，只有Object类型索引值为0 接口索引集合： 一组u2类型数据，入口第一项为u2类型接口计数器 5. 字段表集合字段包括类级变量和实例级变量，不包括局部变量。字段表结构： - access_flags u2 字段修饰符（P$_{176}$,public,private,volatile…) - name_index u2 简单名称 - descriptor u2 字段和方法描述符 - attribute_counts attributes 属性数量和描述 **全限定名：**“org/fenixsoft/clazz/TestClass” **简单名称：** TestClass inc m ... **方法和字段描述符：**：用啦描述字段了数据类型，方法的参数列表和返回值。 - 基本数据类型，void(),对象：`B,C,D,F,I,J,S,Z,V,Ljava/lang/Object` - 数组：&quot;[&quot;例如：`[[java/lang/String`表示`java.lang.String[][]`,`[I`表示`int[]` - 方法：参数列表+返回值：参数列表按顺序放在小括号中`()`例如：`java.lang.String toString(char[] source,int i)`表示为`([CI)Ljava/lang/String` 属性表集合attribute_info将在后面介绍 字段表不会列出从父类继承而来的字段，但是可能列出原本java代码中不存在的字段，比如内部类中会自动添加指向外部类实例的字段。 java语言中字段是无法重载的，两个字段不管数据类型和修饰符是否相同，必须不同名。但是对字节码来讲，只要两个字段描述符不一致，字段重名就是合法的。6. 方法表集合与字段表集合类似，包含访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。方法中的java代码放在属性表集合的code属性中。父类方法在子类中没有重写，方法集合表中就不会出现来自父类的方法信息，但是可能会出现编译器自动添加的方法，如&lt;cinit&gt;和&lt;inti&gt;. java代码层面的方法特征签名：方法名称、参数类型和参数顺序。字节码方面的方法特征签名还包括返回值类型。java语言中方法重载要求与原方法有不同的特征签名，与返回值无关，因为返回值不会包含在特征签名中。 7. 属性表集合属性表与签名的其它表不同，要求没有那么严格，各种编译器可以自己定义属性信息。java虚拟机（Java SE7）中已经有21中预定义属性。（P$_{181}$常见预定义属性）属性表定义应满足的基本结构： u2类型的attribute_name_index 从常量池中引用一个CONSTANT_Utf-8_info类型常量表示属性名称 u4类型attribute_length说明属性占用长度 attribute_length个u1类型数据说明属性 Code属性Code属性存储java方法体中的代码。Code属性表结构（$P_{183}$） attribute_name_index u2 –CONSTANT_Utf_info–固定值“Code” attribute_length u4 属性值长度–整个属性表的长度为attribute_length+6 max_stack u2 操作数栈深度最大值 max_locals u2 局部变量表所需存储空间–slot是局部变量内存所使用最小单位，byte、char……returnAddress–1个slot;double、long–两个slot。方法参数，显示异常处理参数，方法体中的局部变量都存储在局部变量表中；局部变量表中的Slot可以重用，不是有多少局部变量，max_locals就多大。 code_length u4 和code u1 用来存储字节码指令 虽然code_length 为 u4 但是虚拟机规定一个方法不允许超过65535条字节码指令，因此，小心编译JSP文件时方法生成字节码超长导致编译失败 $P_{185}$使用javap命令计算出的字节码指令分析：注意任何实例方法都可以通过this关键字访问到此方法所属对象，是因为在实例方法的局部变量表中至少存在一个指向当前对象的局部变量即Args_size最小值为1 exception_table_length u2 和exception_table exception_info类型 :显示异常处理表集合 $P_{186}$异常表格式 $P_{187}$异常的一个实例 Exceptions属性列出方法中可能抛出的受查异常，即throws关键字后面的异常。 LineNumberTable属性用于描述java源码行号的字节码行号（偏移量）之间的对应关系 LocalVariableTable属性用于描述局部变量表和java源码中定义的变量之间的关系。LocalVariableTypeTable用于描述泛型 SourceFile属性记录生成这个Class文件的源码文件名称 ConstanValue属性通知虚拟机自动为静态变量赋值（static） InnerClass属性记录内部类和宿主类之间的关联 Deprecated和Synthetic属性属于标志类型的布尔属性，只有有何没有的区别，没有属性值的概念。Synthetic表示此字段或方法不是由java源码产生，而是编译器自动生成。 StackMapTalbe在虚拟机类加载的字节码验证阶段被新类型检查器使用 Signature记录泛型签名信息 BootStrapMethods属性保存invokedDynamic指令引用的引导方法限定符 字节码指令简介java虚拟机指令由一个字节长度的、代表某种特定含义的数字（操作码 Opcode)以及跟随其后的零至多个代表此操作所需参数（操作数 Operands）组成。大多指令不含操作数，只有操作码。字节码指令只有一个字节，指令集操作码 总数不能超过255条；表示大于一个字节额数据时要额外消耗部分性能。 字节码和数据类型大多数指令包含其对应的操作类型信息。如：iload,fload。a 代表 refenrencejava虚拟机指令操作码长度只有一个字节，操作码不可能包含所有数据类型，java虚拟机对特定的数据操作只提供了有限的类型相关指令去支持它。必要时可以转换。$P_{199}$java虚拟机指令集支持的数据类型 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。局部变量表=&gt;操作数栈load操作数栈=&gt;局部变量表store常量=&gt;操作数栈 ipush ldc(常量池-&gt;栈顶) const 运算指令rem求余 ineg取反 sh位移 cmp比较只有除法和求余指令除数为0时会抛出异常。其余任何整数运算场景都不应该抛出运行时异常操组溢出–无穷大 没有明确定义NaN 其它指令类型转换：i2b f2l…浮点转换为整型向0取整，溢出的话转换为T所能代表的最大或最小值对象创建和访问：new newarray iaload操作数栈管理：pop dup控制转移：ifeq figt方法调用和返回指令异常处理指令：athrow 抛出；处理-异常表，不是由指令实现同步指令：方法级同步-不通过指令；代码级同步-monitorenter,monitorexit 注：JIT代码生成技术-java虚拟机代码在加载或执行时翻译为宿主机的CPU指令集","link":"/2020/07/18/U6-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"},{"title":"U8-虚拟机字节码执行引擎","text":"概述执行引擎：执行代码的工具，就像发动机引擎一样，通过燃油（编译后代码）让程序跑起来。执行代码的两种方式：解释执行：逐行翻译代码，一条一条的执行，优点是翻译简单，缺点是没有优化，程序执行慢。编译执行：将整段代码编译成本地机器码再执行，优点是可以优化，缺点是编译代码所花时间和性能。即时(Just-In-Time)编译器：JIT编译器 参考链接：https://blog.csdn.net/xiaoliuliu2050/article/details/53023752 运行时栈帧结构栈针：用于支持虚拟机进行方法调用和方法运行时的一种数据结构，存储了方法的局部变量表、操作数栈、动态链接和返回地址等信息。 局部变量表（Local Variable Table） class文件-方法的Code属性-max_locals定义局部变量表最大容量。 以变量槽（Slot）为最小单位，虚拟机规范只是建议了每个Slot要能存放一个byte，char，boolean，short，int，float，reference，returnAddress类型数据，一般实现中一个Slot为32位。 64位数据类型会被分配两个连续的变量空间（高位在前）。 reference表示引用数据类型： 能够查找到对象在java堆中存放的数据的起始地址索引 能搞找到对象所属数据类型在方法区中存放的类型信息 虚拟机通过索引定位方式使用局部变量表，索引范围从0开始。64位数据类型变量同时使用n和n+1两个Slot。 方法执行时，虚拟机通过局部变量表来完成参数值到参数列表的传递过程，如果是实例方法，局部变量表的第0位索引的Slot存放的是方法所属对象的实例引用（this）。 Slot可以重用 $P_{240}$: Slot重用导致内存没有被回收的例子 局部变量没有赋初始值不能使用 操作数栈（Operand Stack） 后进先出 32位数据类型所占栈容量为1,64位数据类型所占栈容量为2 方法执行时，各种字节码指令都是对栈进行操作，包括出栈和入栈 java虚拟机解释执行引擎被称为“基于栈的执行引擎” 动态链接方法调用指令以常量池中指向方法的符号引用作为参数，这些符号引用-静态解析:在类加载阶段或者第一次使用时转化为直接饮用动态链接：在运行时转化为直接引用 栈针信息一般把动态链接、方法返回地址和其它附件信息归为一类，称为栈针信息 方法调用方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本，不涉及方法体内的内容。 1.解析（Resolution）所有方法调用中的目标方法在class文件里都是常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这类方法的调用称为解析。这种类加载的解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个版本在运行期间不可变。即：“编译期可知，运行时不变”主要包括：静态方法和私有方法。 java虚拟机中5条字节码调用指令： invokestatic：调用静态方法 invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法 invokevirtual：调用虚方法 invokeinterface：调用接口方法 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法 非虚方法：静态方法、私有方法、实例构造器、父类方法和final方法。在解析期间可以唯一确定版本，类加载的时候会把符号引用转换为直接引用。其它方法称为虚方法。 解析调用一定是静态的过程；分派调用可能是静态的也能是动态的。 2. 分派1. 静态分派$P_{247}$ 静态分派演示 Human man = new Man();静态类型（Static Type）或外观类型（Apparent Type）：Human实际类型（Actual Type）：Man 静态类型的变化仅仅发生在使用时，变量本身的静态类型不会被改变，最终的静态类型在编译期可知。实际类型发生变化的结果要在运行期才可确定。 //实际类型变化 Human man = new Human(); man = new Women(); //静态类型变化 sr.sayHello((Man)man); sr.sayHello((Woman)man);重载：虚拟机在重载时是通过参数的静态类型作为判定依据的。在编译阶段，javac编译器会根据参数类型决定使用哪个重载版本。 依赖静态类型来定位方法执行版本的分派动作称为静态分派。 典型应用是方法重载，很多情况下重载的版本不唯一，产生这种结论的主要原因是字面量不需要定义，没有显式的静态类型。例：$P_{249}$ 方法重载匹配优先级 注意： 解析与分派并不是二选一的排他关系，他们是在不同纬度上去筛选、确定目标方法的过程。例如：静态方法会在类加载阶段进行解析，但是静态方法也可以有重载版本。 2. 动态分派例：$P_{252}$ 动态分配演示 invokevirtual指令运行时解析过程： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C 在类型C中找到与常量中描述符合简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接饮用，否则返回异常 否则按照基础关系从下往上依次对C的各个父类重复第二步的搜索过程 如果没有找到，返回异常 由于invokevirtual指令第一步就是在运行期间确定接受者的实际类型，所有两次调用invokevirtual指令把常量池中类方法的符号引用解析到了不同的直接引用上，这就是方法重写的本质。 在运行期间根据实际类型确定方法执行版本的过程称为动态分派 3. 单分派与多分派宗量：方法的接受者和方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。 例：$P_{256}$ 单分派和多分派该例子讲述了编译阶段静态分派需要看方法的接受者和方法参数两个宗量，是多分派；运行阶段方法签名已经确定，参数的静态类型和实际类型没有影响，只根据方法的接受者一个因素进行选择，是单分派。总结：截至java 1.7 还是“静态多分派，动态单分派”。 4. 虚拟机动态分派的实现动态分派需要在类的方法元数据中搜索合适的目标方法并且非常频繁，基于性能考虑，使用“虚方法表”进行稳定优化。虚方法表中子类中没有重写父类的方法时，方法入口指向父类的实现，子类重写了父类方法，入口地址则会替换为子类实现的入口地址。虚方法表中相同签名的方法在父类子类的虚方法表中索引序号相同。虚方法表在类加载的连接阶段初始化（准备阶段，准备完实例变量的初始值后）。 动态类型语言支持 动态类型语言类型检查的主体过程在运行期间而不是在编译期间。“变量无类型，而变量值才有类型”–重要特征 java.lang.invoke包带谓词的排序函数（C, C++） void sort(int list[], int size, int (*compare)(int,int))谓词：一个函数对象等，表示动作MethodHandle与Refelection区别： 一个是模拟java代码层面，一个是模拟字节码层面 Reflection包含信息比MethodHandle多很多 MethodHandle 支持字节码优化 *invokeDynamic指令（未完全理解）参考链接：https://blog.csdn.net/zxhoo/article/details/38387141 基于栈的字节码解释执行引擎（略）","link":"/2020/07/18/U8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"title":"U7-虚拟机类加载机制","text":"虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程叫虚拟机的类加载过程。 类加载的时机类生命周期：加载，验证，准备，解析，初始化，使用，卸载7个阶段。验证，准备，解析3部分统称为连接。其中加载，验证，准备，初始化和卸载这5个阶段是按顺序“开始”的，解析阶段有时会在初始化之后“开始”，为了支持Java语言的动态绑定。 虚拟机规范有且只有5种情况必须立即执行类的初始化阶段： new getstatic putstatic invokestatic 4条字节码指令，如果没有初始化，需要先初始化。常见Java代码场景： new对象，读取或设置类的静态字段（final除外-加入了常量池中），调用类的静态方法。 java.lang.reflect包对类反射调用，如果没有初始化，必须先初始化 初始化一个类，发现其父类没有初始化，必须先初始化其父类 虚拟机启动，会先初始化一个主类（main方法所在类） JDK1.7动态语言支持……（到时再补充） 有且只有：这五种场景称为对一个类的“主动引用”，除此之外，所有引用类的方式都不会触发其初始化，称为“被动引用”。$P_{211}$被动引用的三个例子 通过子类引用父类静态字段，不会导致子类的初始化 通过数组定义来引用类，不会触发此类的初始化：虚拟机会自动生成一个数组类，并封装了数组元素的访问方法。 常量（static final）在编译阶段会存入调用类的常量池中，并不会触发被调用类的初始化。 接口的加载过程与类的加载过程稍有不同，一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在用到父接口的时候才会初始化。 类加载过程1 加载加载是类加载过程的一个阶段，需要完成： 通过类的全限定名获取定义此类的二进制字节流 将字节流代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class类型对象，作为方法区这个类的各种数据的访问入口。 如动态代理技术生成代理类的二级制自己流。数组类与类加载器的联系： 如果数组的组件类型为引用类型，就递归采用上述方法加载，数组C将在组件类型类加载器的类名称空间被标识 如果组件类型不是引用类型，数组C与引导类加载器相关联 数组类可见性与组件可见性一致，如果组件不为引用类型，数组可见类型默认为public 2 验证确保Class文件的字节流中包含的信息符合当前虚拟机要求。主要包括： 文件格式验证：验证字节流是否符合class文件格式规范 元数据验证：保证字节码描述信息符合Java语言规范 字节码验证：通过数据流和控制流分析，确定程序语言合法，符合逻辑 符号引用验证：发生在解析阶段将符号引用转换为直接引用的过程中，确保这一过程正常执行。 3 准备准备阶段为类变量分配内存并设置类变量的初始值。 这些变量都在方法区分配内存 仅包括类变量（static）不包括实例变量 通常情况，这里的初始值是指数据类型的0值$P_{220}$基本数据类型的零值 特殊情况，如类字段的字段属性表中存在ConstantValue属性，就会被赋予ConstantValue属性所指定值（如 public static final int value = 1234） 4 解析解析阶段是将常量池中的符号引用转换为直接引用 符号引用： 以一组符号来描述所引用的目标，可以是任何形式的字面量。与虚拟机实现的内存布局无关。 直接引用： 直接指向目标的指针、相对偏移量或一个间接能定位到目标的句柄，和内存布局相关。 虚拟机规范只要求在特定16个（$P_{221}$）用于操作符号引用的字节码指令之前解析。对符号引用的解析结果可以进行缓存，但是对invokedynamic指令不行。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。我们首先了解前面4种，后面3中在第八章了解。$P_{222}$四种引用的解析过程 5 初始化初始化阶段是执行类构造器&lt;clinit&gt;方法的过程。行为细节： 自动收集所有类变量和静态语句块（static{}块）合并产生，顺序按照语句在源文件中的顺序，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，前面的静态语句块可以赋值，但不能访问。 不需要调用父类的构造器，虚拟机会保证在子类的&lt;clinit&gt;方法执行前，父类的&lt;clinit&gt;方法已经执行完毕。 父类的静态语句块要优先于子类的变量赋值操作 &lt;clinit&gt;方法并不是必须的 执行接口的&lt;clinit&gt;方法不需先执行父类的&lt;clinit&gt;方法，接口的实现类在初始化时也不需要先执行接口的&lt;clinit&gt;方法。 虚拟机会保证一个类的&lt;clinit&gt;方法在多线程环境被正确的加锁和同步。 类加载器类加载器相关内容参照Tomcat中类加载章节的笔记","link":"/2020/07/18/U7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"深入理解JVM总结","text":"昨天终于把这本书看完了，虽然有些囫囵吞枣，但是不得不说，收益还是非常大的。只是时间有些长了，看第一次笔记的时间是18年11月5号，到现在用了大概4个月吧。我以前看过一章，这样再算下来，用时5个月把。不过，总的来说，看完的那一刻，还是很有成就感的。下面就粗略回忆下这本书体系结构。 引言、序章和第一章介绍了JDK及其发展史，并引导我们手动编译自己的JDK第二章介绍了JVM 内存模型，对象的生命周期，内存溢出问题的分析；第三章介绍了垃圾回收算法，虚拟机垃圾收集器，垃圾回收的过程；第四章实战部分告诉我们如何分析JVM内存，第五章忘记了，应该也是类似。第六章介绍了class文件结构，Class文件加载过程；第七章介绍了虚拟机执行引擎，介绍了运行时内存区；第八章虚拟机运行class文件的过程。第九章是实践章节，包括类加载机制。第十章介绍了早期优化，语法糖，Java编译成class文件的过程和结构；十一章，介绍了晚期优化过程，逃逸分析等等吧。十二十三章介绍了多线程和高并发，介绍了JVM多线程机制，解决多线程问题的一些方法，包括互斥，乐观锁，非线程冲突，介绍了虚拟机自身的线程优化（各种锁：自旋和自适应，轻量级锁，偏向锁，消除多线程和粗扩展）。记忆中的就这些，有时间的化会看看书再优化一下刚才的语言的。","link":"/2020/07/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E6%80%BB%E7%BB%93/"},{"title":"java并发知识体系简要指南","text":"java并发，是个比较大的知识体系，比较值得一学，网上有很多介绍相关知识点，这篇文章的目的主要是梳理一些相关知识，能够学习的时候更加有条理，不被绕糊涂。并发知识体系 image.png我画了一个图，可以帮助理解相关知识体系： 最底层是硬件CPU的支持和内存理论硬件主要是多核CPU，CAS指令等，JAVA多线程的这套实现机制有很多优化，这些优化都是针对多核CPU的，例如说利用CAS设计的自旋，Sychronizer中的锁升降级。多核就是JAVA多线程设计的一个基本场景，但是在理解的时候很容易被忽略。JMM内存理论，主要是讲一致性、有效性、原子性。这里有很多资料接受，可以自己去查。 中间一大块，就是JAVA的ECF（exception control flow）这块分为两个部分：语言级的实现，Sychronizer，这个模型主要基于管程，可以查一下管程相关的理论。实际上就是把对象和线程结合在一起实现管程，对象的结构中存储轻量级锁、偏向锁、重量级锁的数据，在java虚拟机中，调度的时候通过一定的条件，进行锁的升降级，这是一种优化设计，通过这种优化设计确保在不必要加锁（中断，因为中断会导致上下文切换）。Concurrent Lock，JDK5及以后实现的比较新的Lock系列，可以发现比较新的JDK源码和各种开源代码都是基于lock系列实现的，因为基于lock实现的代码确实比基于管程的实现效率高。图中画出了实现的层级，理解这一块，需要去读源码，实现分为三层：最底层是unsafe，封装了比较重要的CAS和park两种实现基础，然后在这个上一层是实现的中间层通用代码LockSport和AQS，最上层则是Lock、Sepmophore、cond、CountDownLanch、CyclicBarrier具体的lock工具，是锁在各种场景下的语义封装。 Thread层，线程本身，线程本身需要理解线程的状态，线程的Runnable、Callable、Future两种基础形态，因为Callable和Future出现的比较晚，所以是和线程池紧紧结合在一起的。 最上层，这是在线程和线程ECF上封装的各种工具类：原子类，有四种，可以直接看源码，AtomicInteger等，都是基于CAS实现的。容器类，包括Map、Queue的各种线程安全变体，其中对于Queue，有PriorityBlockedQueue、LinkedBlockedQueue、ArrayBlockedQueue等，需要理解的是这些各种容器支持的场景、算法以及优缺点，这块也是比较大的知识体系。特别说明的是，对于多核场景下，这些有锁的容器出现意义很大，现实世界，都是多核、集群或者异地并发的场景，算法和锁结合设计出新的数据结构和算法。最上层就是并发框架，包括线程池、Fork/Join、CompleteFuture等.小结JAVA并发是个比较大的知识体系，想学好不容易，资料特别多，知识点也特别多，如果不搞清楚这个知识结构，就会陷入到各种细节中顾此失彼。本文没有讲比较详细的细节，后面会用几个章节对比较感兴趣的一些点讲述一下。 作者：Wu杰语链接：https://www.jianshu.com/p/6d428439d27f","link":"/2020/07/18/java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%AE%80%E8%A6%81%E6%8C%87%E5%8D%97/"},{"title":"java并发编程体系2-lock&amp;synchronized","text":"一般这个问题在面试的时候由一个问题引出：lock和syncronized有什么区别。这个时候就看你对并发编程的理解情况了，这里可以引出并发编程的整个体系。下面分别介绍。 Lock模型 AQS(AbstractQuenedSynchronizer抽象队列式同步器) 核心思想&amp;基本框架 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程等待队列CLH(多线程竞争state被阻塞时会进入此队列)。 state共享资源变量state,三种访问方式： getState() setState(int newState) compareAndSetState(int expect, int update) 资源共享的方式，两种： 独占式(Exclusive)只有单个线程能够成功获取资源并执行，如ReentrantLock。 共享式(Shared)多个线程可成功获取资源并执行，如Semaphore/CountDownLatch等。 同步器可重入的方法：AQS将大部分的同步逻辑均已经实现好，继承的自定义同步器只需要实现state的获取(acquire)和释放(release)的逻辑代码就可以，主要包括下面方法： tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 AQS需要子类复写的方法均没有声明为abstract，目的是避免子类需要强制性覆写多个方法，因为一般自定义同步器要么是独占方法，要么是共享方法，只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。当然，AQS也支持子类同时实现独占和共享两种模式，如ReentrantReadWriteLock。 CLHAQS内部的FIFO线程等待队列，通过内部类Node来实现. 相关概念CLH是一种基于单向链表(隐式创建)的高性能、公平的自旋锁.详情了解可以参考下面两篇博客：简单的非公平自旋锁以及基于排队的公平自旋锁的实现CLH锁的原理和实现 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static final class Node { // 表明节点在共享模式下等待的标记 static final Node SHARED = new Node(); // 表明节点在独占模式下等待的标记 static final Node EXCLUSIVE = null; // 表征等待线程已取消的 static final int CANCELLED = 1; // 表征需要唤醒后续线程 static final int SIGNAL = -1; // 表征线程正在等待触发条件(condition) static final int CONDITION = -2; // 表征下一个acquireShared应无条件传播 static final int PROPAGATE = -3; /** * SIGNAL: 当前节点释放state或者取消后，将通知后续节点竞争state。 * CANCELLED: 线程因timeout和interrupt而放弃竞争state，当前节点将与state彻底拜拜 * CONDITION: 表征当前节点处于条件队列中，它将不能用作同步队列节点，直到其waitStatus被重置为0 * PROPAGATE: 表征下一个acquireShared应无条件传播 * 0: None of the above */ volatile int waitStatus; // 前继节点 volatile Node prev; // 后继节点 volatile Node next; // 持有的线程 volatile Thread thread; // 链接下一个等待条件触发的节点 Node nextWaiter; // 返回节点是否处于Shared状态下 final boolean isShared() { return nextWaiter == SHARED; } // 返回前继节点 final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } // Shared模式下的Node构造函数 Node() { } // 用于addWaiter Node(Thread thread, Node mode) { this.nextWaiter = mode; this.thread = thread; } // 用于Condition Node(Thread thread, int waitStatus) { this.waitStatus = waitStatus; this.thread = thread; }} 参考链接：https://www.jianshu.com/p/0f876ead2846 Synchronized模型synchronized是java中的关键字。可以通过管程的学习来具体了解一下这个模型。https://blog.csdn.net/qq_38095094/article/details/84669095 这里介绍一下JVM中关于它的锁优化相关内容 锁 同步代码块：monitorenter指令插入到同步代码块的开始位置。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁 同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。 偏向锁轻量级锁重量级锁重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。 其它参考：https://www.jianshu.com/p/6d428439d27f","link":"/2020/07/18/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BD%93%E7%B3%BB2-lock-synchronized/"}],"tags":[{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"bat命令","slug":"bat命令","link":"/tags/bat%E5%91%BD%E4%BB%A4/"},{"name":"Java并发编程","slug":"Java并发编程","link":"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"},{"name":"Web容器","slug":"Web容器","link":"/tags/Web%E5%AE%B9%E5%99%A8/"},{"name":"Http","slug":"Http","link":"/tags/Http/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"生产工具","slug":"生产工具","link":"/categories/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"},{"name":"常用框架","slug":"常用框架","link":"/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"JVM","slug":"编程语言/JVM","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JVM/"},{"name":"Java","slug":"编程语言/Java","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"},{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"maven","slug":"生产工具/maven","link":"/categories/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/maven/"},{"name":"Java并发编程","slug":"编程语言/Java并发编程","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Mybatis","slug":"常用框架/Mybatis","link":"/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Mybatis/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Zookeeper","slug":"中间件/Zookeeper","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/"},{"name":"tomcat","slug":"计算机网络/tomcat","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tomcat/"},{"name":"Web容器","slug":"计算机网络/Web容器","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Web%E5%AE%B9%E5%99%A8/"},{"name":"Dubbo","slug":"中间件/Dubbo","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/"}]}